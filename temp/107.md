
## python数据存储原理
**变量 引用 对象**
```
x = 1
```

内存中只创建了对象`1`，变量x只是贴在对象`1`的标签，`=`是赋值即引用
在python中一切皆对象，里面又有不可变对象和可变对象

### 数字和字符串对象引用
```
>>> a = 5                   # 内存中创建了一个对象5
>>> b = 5
>>> b       --> 5
>>> id(a)   --> 139774080
>>> id(b)   --> 139774080   # 一个对象贴了两个标签
>>> b = 3                   # 内存中新建了一个对象3
>>> id(b)   --> 10923616    # 对象引用换成了b
```

### 组合对象的引用(除了数字和字符串)
> 可以创建多个"一样"的对象,但是id不同
```
>>> x = [1, 2, 3]
>>> id(x)         --> 140150136275912
>>> y = x[:]
>>> y             --> [1, 2, 3]
>>> id(y)         --> 140150136287496
>>> z = [1, 2, 3]
>>> id(z)         --> 140150136287944
```

解析:
```
>>> x = 'a'
>>> y = ['a', 1, ['a', 1]]
>>> id(x)        --> 140363897810368   # 对象'a'
>>> id(y)        --> 140363897692872   # 列表对象
>>> id(y[0])     --> 140363897810368
>>> id(y[1])     --> 10923552          # 列表的子对象数字1
>>> id(y[2])     --> 140363897680840   # 列表子对象列表['a', 1]
>>> id(y[2][0])  --> 140363897810368   # 三个 'a' id一样
>>> id(y[2][1])  --> 10923552          # 两个 1 id一样
```

修改列表内容：
```
>>> y.remove(['a', 1])
>>> y     --> ['a', 1]
>>> id(y) --> 140363897692872   # 因为是修改原对象，所有id不变
```

#### 可变对象的浅拷贝
```
>>> x = {'a':1, 'b':[1, 2, 3]}          # 最底层的对象只有1,2,3
>>> y = x.copy()
>>> y            --> {'a':1, 'b':[1, 2, 3]}
>>> id(x)        --> 139791973166088
>>> id(y)        --> 139791973166024    # 父对象id显示不一样
>>> id(x['a'])   --> 10923552
>>> id(y['a'])   --> 10923552           # 子对象id一样
>>> id(x['b'])   --> 139791972639688
>>> id(y['b'])   --> 139791972639688    # 子对象id一样
```

> 从上面可以看出，浅复制只是创建一个新的父对象，子对象还是同一个对象

修改字典的列表
```
>>> id(y['b'][1])   --> 10923584
>>> y['a'] = 2                           # 引用对象2
>>> id(y['a'])      --> 10923584
>>> y['b'].remove(2)
>>> id(y['b'])      --> 139791972639688  # 列表子对象id没有改变
>>> y               --> {'b': [1, 3], 'a': 1}
>>> x               --> {'b': [1, 3], 'a': 1}
```

### 导入copy模块实现deep copy
```
>>> import copy
>>> x = {'a':1, 'b':[1, 2, 3]}
>>> y = copy.copy(x)                # 浅拷贝和前面一样
>>> z = copy.deepcopy(x)            # 深拷贝
>>> id(x['b'])  --> 140541619106696
>>> id(z['b'])  --> 140541618998536 # 创建了两个列表对象
>>> z['b'].remove(2)
>>> x           --> {'a': 1, 'b': [1, 2, 3]}
>>> z           --> {'a': 1, 'b': [1, 3]}
```

> deepcopy可以创建两个id不一样的可变对象，但不影响不可变对象

### 变量
python引用变量的顺序： 当前作用域局部变量->外层作用域变量->当前模块中的全局变量->python内置变量 
global和nonlocal
```
a = 1           # 全局变量，可省略global关键字
def y():
    a = a + 1   # 全局变量可以在函数内部使用，但不能修改

y()             # 报错
```

#### 变量解析规则
在python的作用域规则里面，创建变量一定会在当前作用域里创建一个变量，但是访问或者修改变量时会先在当前作用域查找变量，没有找到匹配变量的话会依次向上在闭合的作用域里面进行查看找

* 声明全局变量，如果在局部要对全局变量修改，需要在局部也要先声明该全局变量
* 在局部如果不声明全局变量，并且不修改全局变量。则可以正常使用全局变量
* nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量

> 避免出错的办法，就是尽量不重复使用