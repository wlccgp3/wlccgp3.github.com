

```
def bar():
    print('hello')
def foo():
    bar()           # foo()内部并没有定义bar(),

foo()
```

作用域原理:
```
scopes = {
    "local": {"locals": None,
             "non-local": {"locals": None,
                          "global": {"locals": None,
                                    "built-in": ["built-ins"]}}},
}
```
普通的局部变量对最内层局部作用域之外只有只读(read-only)的访问权限

## 命名空间(namespace)

### 全局变量和局部变量

全局变量和局部变量，是理解命名空间的起始。

局部变量和全局变量是在不同的范围内起作用。所谓的不同范围，就是变量产生作用的区域，简称作用域。

### 作用域

所谓作用域，是“名字与实体的绑定保持有效的那部分计算机程序”（引自《维基百科》），用直白的方式说，就是程序中变量与对象存在关联的那段程序。如果用前面的例子说明，`x = 2`和`x = 9`是处在两个不同的作用域中。

通常，把作用域还分为静态作用域和动态作用域两种，虽然Python是所谓的动态语言（不很严格的划分），但它的作用域属于静态作用域，意即Python中变量的作用域由它在程序中的位置决定，如同上面例子中的`x = 9`位于函数体内，它的作用域和`x = 2`就不同。

那么，Python的作用域是怎么划分的呢？可以划分为四个层级：

1. Local：局部作用域，或称本地作用域
2. Enclosing：嵌套作用域
3. Global：全局作用域
4. Built-in：内建作用域

对于一个变量，Python也是按照上述从前到后的顺序，在不同作用域中查找。在刚才的例子中，对于`x`，首先搜索的是函数体内的本地作用域，然后是函数体外的全局作用域。

    #!/usr/bin/env python
    #coding:utf-8

    def outer_foo():
        a = 10
        def inner_foo():
            a = 20
            print "inner_foo,a=", a      #a=20
                                                               #Python 3的读者，请自行修改为print()函数形式，下同，从略
        inner_foo()
        print "outer_foo,a=", a          #a=10

    a = 30
    outer_foo()
    print "a=", a                #a=30
    
运行结果

    inner_foo,a= 20
    outer_foo,a= 10
    a= 30

仔细观察上述程序和运行结果，你会看出对变量在不同范围进行搜索的规律的。

在Python程序中，变量的作用域是有在函数、类中才能被改变，或者说，如果不是在函数或者类中，比如在循环或者条件语句中，变量都是在同一层级的作用域中。可以再次参考上述的示例，并且可以在上述示例中修改，检测你的理解。
    
### 命名空间

命名空间因为对象的不同，也有所区别，可以分为如下几种：

1. 本地命名空间(Function&Class: Local Namespaces)：模块中有函数或者类，每个函数或者类所定义的命名空间就是本地命名空间。如果函数返回了结果或者抛出异常，则本地命名空间也结束了。
2. 全局命名空间(Module:Global Namespaces)：每个模块创建它自己所拥有的全局命名空间，不同模块的全局命名空间彼此独立，不同模块中相同名称的命名空间，也会因为模块的不同而不相互干扰。
3. 内置命名空间(Built-in Namespaces)：Python运行起来，它们就存在了。内置函数的命名空间都属于内置命名空间，所以，我们可以在任何程序中直接运行它们，比如前面的id(),不需要做什么操作，拿过来就直接使用了。

程序在查询上述三种命名空间的时候，就按照从里到外的顺序，即：Local Namespaces --> Global Namesspaces --> Built-in Namesspaces

    >>> def foo(num,str):
    ...     name = "qiwsir"
    ...     print locals()
    ... 
    >>> foo(221,"qiwsir.github.io")
    {'num': 221, 'name': 'qiwsir', 'str': 'qiwsir.github.io'}
    >>> 

这是一个访问本地命名空间的方法，用`print locals()` 完成，从这个结果中不难看出，所谓的命名空间中的数据存储结构和字典是一样的。

根据习惯，读者一定已经猜测到了，如果访问全局命名空间，可以使用 `print globals()`。

对于不同的命名空间，除了存在查找的顺序之外，还有不同的生命周期，即什么时候它存在，什么时候它消失了。对此，在理解上比较简单，那就是哪个部分被读入内存，它相应的命名空间就存在了。比如程序启动，内置命名空间就创建，一直到程序结束；而其它的，比如本地命名空间，就是在函数调用时开始创建，函数执行结束或者抛出异常时结束。

------
