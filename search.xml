<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[README.md]]></title>
    <url>%2F2018%2F01%2F11%2FREADME%2F</url>
    <content type="text"><![CDATA[网站插件扩展 hexo-deployer-git hexo-generator-searchdb disqus 配置文件问题主题配置可以放在source/_data/next.yml中，会覆盖掉主题内的配置站点配置不能写在source/_data/next.yml中，有的不能生效 gitment在github设置中Settings/Developer settings 创建一个新OAuth app注意：Homepage URL和Authorization callback URL就写github page里面显示的域名，如果绑定了域名，github page也会显示成绑定的域名]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2013%2F07%2F13%2Ftest%2F</url>
    <content type="text"><![CDATA[test123]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[htmls]]></title>
    <url>%2Fhtml%2Findex.html</url>
    <content type="text"><![CDATA[bokeh快速入门]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F101.html</url>
    <content type="text"><![CDATA[python3基础语法python是一种解释型语言 Linux环境下编程打开终端输入python3即可进入python3 shell，要打开py文件直接在py文件所在位置终端输入python3 *.py，或输入绝对路径打开1234#!/usr/bin/env python3 # linux系统下必须，这是python3的环境变量#coding:utf-8 # 申明编码，非必须，便于阅读和维护a = 19 + 2 * 4 - 8 / 2 # 表达式print(a) # 函数 编译当运行.py文件的时候，Python会通过编译器，将它编译为.pyc文件。然后这个文件就在一个名为虚拟机的东西上运行，这个所谓的虚拟机是专门为Python设计的。有了虚拟机，使得Python可以跨平台 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。也可以为源码文件指定不同的编码： # -*- coding: cp-1252 -*- 标识符(给对象起名字) 一切皆可为对象 第一个字符必须是字母表中字母或下划线_。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 python保留字123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;] 注释 注释的作用便于读写和维护代码 单行注释用# # 程序运行时该注释不会显示 多行注释用三对引号 &quot;&quot;&quot; 多行注释 多行注释 &quot;&quot;&quot; 缩进与空格 python最具特色的就是使用缩进来表示代码块，不需要使用大括号{}。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数，为了统一规范一般用4个空格。 为了代码的整体美观、便于阅读和便于维护，用空格隔开不同的元素 代码换行 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\来实现多行语句，例如： 123total = item_one + \ item_two + \ item_three 在[] {}或()中的多行语句，不需要使用反斜杠\，例如： 12total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;, &apos;item_four&apos;, &apos;item_five&apos;] 一行显示多条语句,Python可以在同一行中使用多条语句，语句之间使用分号;分割: 1import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;) 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 在Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。对象有类型，变量无类型 数据类型Number（数字） int float boolTrue False，首字母必须大写 complex1+2jString可以索引和切片，不能被改变List有序，可以索引、切片、可变Tuple可以索引和切片，不能被改变Dictionary — {key:value}无序，元素是一对键值Set — {1,’a’}集合是一个无序不重复元素的序列。创建一个空集合必须用set()而不是{}，因为{}是用来创建一个空字典。| id()可以查看内存地址type()查看数据类型 变量在Python中，有这样一句话是非常重要的：对象有类型，变量无类型。Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。等号=用来给变量赋值。等号=运算符左边是一个变量名,等号=运算符右边是存储在变量中的值 Python3运算符 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 算术运算符a=10 b=4 运算符 描述 实例 结果 + 加 a+b 14 - 减 a-b 6 * 乘 a*b 40 / 除 a/b 2.5 % 取余 a%b 2 ** 幂 a**b 10000 // 取整除 a//b 2 凡是浮点型参与计算，结果都为浮点型 比较运算符a=10 b=4 运算符 描述 实例 结果 == 等于 a==b False != 不等于 a!=b True &gt; 大于 a&gt;b True &lt; 小于 a&lt;b False &gt;= 大于等于 a&gt;=b False &lt;= 小于等于 a&lt;=b False 赋值运算符 运算符 实例 描述 = c=a+b += c+=a c=c+a -= c-=a c=c-a *= c*=a c=c*a /= c/=a c=c/a %= c%=a c=c%a **= c**=a c=c**a //= c//=a c=c//a 位运算符 按位运算符是把数字看作二进制来进行计算的。 运算符 描述 &amp; 按位与运算符；参与运算符的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 按位或 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 ^ 按位异或运算符；当两队应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 按位或运算符|，md表格不能打出| 逻辑运算符and or not 成员运算符in not in 身份运算符is is not 运算符优先级 优先级 运算符 1 ** 2 ~ + - 3 * / % // 4 + - 5 &gt;&gt; &lt;&lt; 6 &amp; 7 ^ 按位或 8 &lt;= &lt;&gt; &gt;= 9 &lt;``&gt; == != 10 = %= /= //= -= += *= **= 11 is is not 12 in not in 13 not or and float精度问题&gt;&gt;&gt; 0.1 + 0.2 0.30000000000000004 &gt;&gt;&gt; 0.1 + 0.1 + 0.1 - 0.3 5.551115123125783e-17 原因在于十进制和二进制的转换上，电脑用的是二进制进行计算，上面的例子中，我们输入的是十进制，她就要把十进制的数转化为二进制，然后再计算。但是，在转化中，浮点数转化为二进制，就出问题了。 例如十进制的0.1，转化为二进制是：0.0001100110011001100110011001100110011001100110011… 也就是说，转化为二进制后，不会精确等于十进制的0.1。同时，计算机存储的位数是有限制的，所以，就出现上述现象了。这种问题不仅仅是Python中有，所有支持浮点数运算的编程语言都会遇到，它不是Python的bug。 使用numPy包和其它用于数学和统计学的包，可以解决上述问题 常用数学函数 函数 代码实例 返回值 描述 abs(x) abs(-1.2) 1.2 返回 x（数字）的绝对值，如果参数是一个复数，则返回它的大小 max(x) max(1,2) 2 返回给定参数的最大值，参数可以为序列 min(x) min(1,2) 1 返回给定参数的最小值，参数可以为序列 round(x[,n]) round(3.14,1) 3.1 返回浮点数x的四舍五入值,第二个参数规定保留的小数位数，不写则默认为0 math模块math是标准库之一，所以不用安装，可以直接使用。使用方法是： &gt;&gt;&gt; import math 函数 代码实例 返回值 描述 ceil(x) math.ceil(1.2) 2 返回一个大于或等于 x 的的最小整数 floor(x) math.floor(-1.2) -2 返回一个小于或等于 x 的的最小整数 exp(x) math.exp(math.pi) 23.140692632779267 返回x的指数,ex fabs(x) math.fabs(-1.2) 1.2 返回数字的绝对值,只对浮点型跟整型数值有效 sqrt(x) math.sqrt(100) 10 返回数字x的平方根 dir(module)：查看命令的属性和方法help()：查看帮助 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。1&gt;&gt;&gt; import random choice(seq)方法返回一个列表，元组或字符串的随机项 12random.choice(&apos;Runoob&apos;)---&gt;urandom.choice([1, 2, 3, 5, 9]))---&gt;3 randrange ([start,] stop [,step])方法返回指定递增基数集合中的一个随机数，基数缺省值为1。 start – 指定范围内的开始值，包含在范围内。 stop – 指定范围内的结束值，不包含在范围内。 step – 指定递增基数。1234# 从 1-100 中选取一个奇数random.randrange(1, 100, 2)---&gt;97# 从 0-99 选取一个随机数random.randrange(100)---&gt;42 random() 方法返回随机生成的一个实数，它在[0,1)范围内。 random.random()—&gt;0.09690599908884856 random.seed([x])改变随机数生成器的种子,此方法没有返回值。参数x 改变随机数生成器的种子seed。不必特别去设定seed，Python会选择seed。 random.shuffle(lst)方法将列表和元组的所有元素随机排序。 123list1 = [20, 16, 10, 5]random.shuffle(list1)list1 ---&gt;[20, 5, 16, 10] uniform(x, y)在[x,y]范围内,随机生成一个实数。 1random.uniform(5, 10)---&gt;7.054602800254241]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F102.html</url>
    <content type="text"><![CDATA[字符串在python中字符串用单引号&#39;&#39;或双引号&quot;&quot;，本身不能修改 字符串基本操作字符串是一种序列，所有序列都有如下基本操作，这是序列共有的操作。 实例 结果 描述 len() len(‘abc’) 3 求序列长度 + ‘a’+’1’ a1 连接2个序列，必须是同类型数据 * ‘a’*3 ‘aaa’ 重复序列元素 in ‘a’in’abc’‘d’in’abc’ TrueFalse 判断元素是否存在于序列中 max() max(‘abc’) ‘c’ 返回最大值，大小排序符合字符编码 min() min(‘abc’) ‘a’ 返回最小值，大小排序符合字符编码 用比较运算符比较大小 索引和切片12345&gt;&gt;&gt; lang = &quot;study python&quot;&gt;&gt;&gt; lang[0] ---&gt; &apos;s&apos;&gt;&gt;&gt; lang[1] ---&gt; &apos;t&apos;&gt;&gt;&gt; &quot;study python&quot;[0] ---&gt; &apos;s&apos;&gt;&gt;&gt; lang.index(&quot;p&quot;) ---&gt; 6 0 1 2 3 4 5 6 7 8 9 10 11 s t u d y p y t h o n -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 第一个不是用数字1表示，而是用数字0表示 切片 结果 描述 str[start:end:step] 默认正向切片 切片取值：前包括后不包括step为空时，缺省值为1step&lt;0时，则反向切片 lang[1:] ‘tudy python’ 得到从1号到最末尾的字符,此时最后那个可以不写 lang[:] ‘study python’ 得到所有字符 lang[:10] ‘study pyth’ 得到从第一个到10号之前的字符 lang[1:4:2] ‘td’ 得到以step=2从1到4的字符 lang[::-1] ‘nohtyp yduts’ 反向得到所有字符 Python转义字符在字符串中，总会有一些特殊的符号，就需要用转义符。所谓转义，就是不采用符号本来的含义，而采用另外一含义。下面表格中列出常用的转义符： 转义字符 描述 \ (在行尾时) 续行符 \\ 反斜杠符号 \&#39; 单引号 \&quot; 双引号 \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数，yy代表的字符，例如：\o12代表换行 \xyy 十六进制数，yy代表的字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 常用的字符串方法 dir(str)列出字符的属性和方法hlep(str)查看帮助 capitalize()&apos;abc&apos;.capitalize() ---&gt;&apos;Abc&apos; 将字符串的第一个字符改为大写 casefold()&apos;ABc&apos;.casefold() ---&gt; &apos;abc&apos; 将整个字符串的所有字符改为小写,可用处理unicode center(width[, fillchar])‘abc’.center(5,) —&gt; ‘\abc*‘返回一个指定的宽度 width 居中的字符串，如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充 count(sub[, start[, end]])&apos;aabc&apos;.count(&apos;a&apos;) ---&gt; 2 返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。 encode(encoding=’utf-8’, errors=’strict’)以 encoding 指定的编码格式对字符串进行编码。 expandtabs([tabsize=8])将字符串中的tab(\t)转换为空格，如不指定参数，默认的空格数是 tabsize=8。 find(sub[, start[, end]])&apos;abc&apos;.find(&apos;c&apos;) ---&gt; 2 检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围。 index(sub[, start[, end]])‘abc’.index(‘c’) —&gt; 2跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。 join(sub)&apos;-&apos;.join(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) ---&gt; &apos;a-b-c&apos; 以字符串作为分隔符，插入到 sub 中所有的字符之间。| lower()&apos;ABC&apos;.lower() ---&gt; &apos;abc&apos; 转换字符串中所有大写字符为小写。只对 ASCII 也就是 ‘A-Z’有效 upper()&apos;abc&apos;.upper() ---&gt; &apos;ABC&apos; 转换字符串中的所有小写字符为大写。 lstrip()去掉字符串左边的所有空白占位符(包括\n\t等) rstrip()删除字符串末尾的空白占位符(包括\n\t等)。 strip([chars])删除字符串前边和后边所有的空白占位符(包括\n\t等)，chars 参数可以定制删除的字符 replace(old, new[, count])把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。 title()返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。| 字符串格式化输出12&gt;&gt;&gt; &quot;I like %s and %s&quot; % (&quot;python&quot;,&apos;music&apos;) # 从左至右一一对应&apos;I like python and music&apos; 格式化符号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %p 用十六进制数格式化变量的地址 format()方法匿名参数12345&gt;&gt;&gt; &quot;I like &#123;0&#125; and &#123;1&#125;&quot;.format(&quot;python&quot;, &quot;markdown&quot;)&apos;I like python and markdown&apos;&gt;&gt;&gt; &quot;I like &#123;1&#125; and &#123;0&#125;&quot;.format(&quot;python&quot;, &quot;markdown&quot;)&apos;I like markdown and python&apos; 命名参数，参数可重用12&gt;&gt;&gt; &apos;姓名：&#123;name&#125;, 年龄：&#123;age&#125;,虚岁：&#123;age&#125;&apos;.format(name=&apos;wanli&apos;, age=26)&apos;姓名：wanli, 年龄：26, 虚岁：26&apos; 序列下标list和tuple可以通过“打散”成普通参数给函数12&gt;&gt;&gt; &apos;&#123;0&#125; and &#123;1&#125;&apos;.format(&apos;abc&apos;[2], [2,3][1])&apos;t and 3&apos; for循环格式化输出12for x in range(1, 11):print(&apos;&#123;0:2d&#125; &#123;1:3d&#125;&apos;.format(x, x*x)) 填充和对齐既然是“格式化”，就要指定一些格式，让输出的结果符合指定的样式。填充常跟对齐一起使用^ &lt; &gt;分别是居中、左对齐、右对齐，后面带宽度:后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充 传入字符串(默认左对齐)12345678&gt;&gt;&gt; &quot;I like &#123;0:10&#125; and &#123;1:&gt;15&#125;&quot;.format(&quot;python&quot;, &quot;markdown&quot;)&apos;I like python and markdown&apos;&gt;&gt;&gt; &quot;I like &#123;0:&lt;10&#125; and &#123;1:^15&#125;&quot;.format(&quot;python&quot;, &quot;markdown&quot;)&apos;I like python and markdown &apos;&gt;&gt;&gt; &quot;I like &#123;0:.2&#125; and &#123;1:*^10.4&#125;&quot;.format(&quot;python&quot;, &quot;markdown&quot;)&apos;I like py and ***mark***&apos; {0:10} {0:&lt;10}：表示第一个位置，占10个字符长度，并且该位置字符左对齐{1:&gt;15}：表示第二个位置，占15个字符长度，并且该位置字符右对齐。{1:^15}：表示第二个位置，占15个字符长度，并且该位置字符居中对齐。{0:.2}：在: .之间，没有任何数字，表示自适应放入字符，.2表示对于传入的字符串，截取前两个。 传入数字(默认右对齐)1234567891011&gt;&gt;&gt; &quot;π=&#123;:10.4&#125;&quot;.format(3.14159265358979)&apos;π= 3.142&apos;&gt;&gt;&gt; &quot;π=&#123;:10.4f&#125;&quot;.format(3.14159265358979)&apos;π= 3.1416&apos;&gt;&gt;&gt; &quot;π=&#123;:010.4f&#125;&quot;.format(3.14159265358979)&apos;π=00003.1416&apos;&gt;&gt;&gt; &quot;π=&#123;:0&gt;10.4f&#125;&quot;.format(3.14159265358979)&apos;π=00003.1416&apos; {:10.4f}：.4f表示传入的是float类型，且保留4位小数 因为传入的是数字默认右对齐，所以{:010.4f}和{:0&gt;10.4f}结果一样，但是{:010.4f}很容易看懵逼 根据分隔符分割字符串split()的作用是将字符串根据某个分割符进行分割，返回的是一个列表。1234567891011&gt;&gt;&gt; a = &quot;I LOVE PYTHON&quot;&gt;&gt;&gt; a.split() # 不带参数时默认是空白占位符[&apos;I&apos;, &apos;LOVE&apos;, &apos;PYTHON&apos;]&gt;&gt;&gt; b = &quot;www.baidu.com&quot;&gt;&gt;&gt; b.split(&quot;.&quot;) # 以‘.’分割[&apos;www&apos;, &apos;baidu&apos;, &apos;com&apos;]&gt;&gt;&gt; c=&apos;abc[www.baidu.com]def&apos;&gt;&gt;&gt; c.split(&apos;[&apos;)[1].split(&apos;]&apos;)[0] # 提取[]之间的字符串&apos;www.baidu.com&apos; 从左向右分步解析123456c.split(&apos;[&apos;)[1] [&apos;abc&apos;,&apos;www.baidu.com]def&apos;][1] &apos;www.baidu.com]def&apos; .split(&apos;]&apos;)[0] [&apos;www.baidu.com&apos;,&apos;def&apos;][0] &apos;www.baidu.com&apos; 用正则表达式提取字符串1234&gt;&gt;&gt; import re&gt;&gt;&gt; c=&apos;abc[www.baidu.com]def&apos;&gt;&gt;&gt; re.findall(r&apos;\[(.*)\]&apos;,c) # 转义\[ [&apos;www.baidu.com&apos;] # 返回一个列表 用join()拼接字符串 虽然+能够拼接字符串，但是有时候没有.join()方便&#39;sep&#39;.join(seq)：以sep作为分隔符，将seq所有的元素合并成一个新的字符串12345&gt;&gt;&gt; b = &apos;www.baidu.com&apos;&gt;&gt;&gt; c = b.split(&quot;.&quot;)&gt;&gt;&gt; c ---&gt; [&apos;www&apos;, &apos;baidu&apos;, &apos;com&apos;]&gt;&gt;&gt; &quot;.&quot;.join(c) ---&gt; &apos;www.baidu.com&apos;&gt;&gt;&gt; &quot;*&quot;.join(c) ---&gt; &apos;www*baidu*com&apos;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F103.html</url>
    <content type="text"><![CDATA[列表 基本操作 索引和切片 更新列表 删除列表元素 常用的列表函数 list.append(obj) list.extend(seq) list.insert(index,obj) list.copy() list.clear() list.count(obj) list.index(obj) list.pop([index]) list.remove(obj) list.reverse() list.sort(key=None, reverse=False) 列表表也是一种序列，每个元素以逗号,分开。列表无所不包，里面可以放各种类型的数据，且里面所能容纳的元素数量无限，当然这是在硬件设备理想的情况下。 列表元素可以修改 基本操作和前面《字符串》的基本操作类似，在list中，也有类似的操作。只不过是以元素为单位，不是以字符为单位进行索引了。 实例 结果 描述 len() len[‘ab’,1] 2 求序列长度 + [‘ab’]+[1] [‘ab’, 1] 连接2个序列，必须是同类型数据 * [‘a’]*2 [‘a’, ‘a’] 重复序列元素 in ‘ab’in[‘ab’,1]‘a’in[‘ab’,1] TrueFalse 判断元素是否存在于序列中 max() max([‘a’,’b’]) ‘a’ 返回最大值，大小排序符合字符编码，列表内元素必须是同种类型的数据 min() min([2,1]) 1 返回最小值，大小排序符合字符编码，列表内元素必须是同种类型的数据 用比较运算符比较大小，不过必须是同种类型的数据才能比较 索引和切片12345&gt;&gt;&gt; y = [&apos;a&apos;, 1, &apos;a&apos;, [3]]&gt;&gt;&gt; y[0] ---&gt; &apos;a&apos;&gt;&gt;&gt; y[1] ---&gt; 1&gt;&gt;&gt; y.index(&apos;a&apos;) ---&gt; 0 # 检索该元素在列表中第一次出现的位置&gt;&gt;&gt; [&apos;a&apos;,1][0] ---&gt; &apos;a&apos; 切片 结果 描述 list[start:end:step] 默认正向切片 切片取值：前包括后不包括end必须大于start,否则返回空step为空时，缺省值为1step&lt;0时，则反向切片 y[1:] [ 1, ‘a’, [3]] 得到从2号到最末尾的元素,这时最后那个可以不写 y[:] [‘a’, 1, ‘a’, [3]] 得到所有元素 y[:2] [‘a’, 1] 得到2之前(不包括第三个)的元素 y[0:3:2] [‘a’, ‘a’] 得到以step=2从0到3(不包括3)的元素 y[::-1] [[3], ‘a’, 1, ‘a’] 反向得到所有元素 如果列表内有序列(字符串、列表等)，则可以进行二次索引和切片12&gt;&gt;&gt; y = [&apos;a&apos;, 1, &apos;abc&apos;, 2, [3]]&gt;&gt;&gt; y[2][:2] ---&gt; &apos;ab&apos; 更新列表123&gt;&gt;&gt; y = [&apos;a&apos;, 1, &apos;abc&apos;]&gt;&gt;&gt; y[1] = &apos;python&apos;&gt;&gt;&gt; y ---&gt; [&apos;a&apos;,&apos;python&apos;,&apos;abc&apos;] 删除列表元素123&gt;&gt;&gt; y = [&apos;a&apos;, 1,&apos;abc&apos;, &apos;a&apos;]&gt;&gt;&gt; del list1[1] &gt;&gt;&gt; y ---&gt; [&apos;a&apos;, &apos;abc&apos;, &apos;a&apos;] 常用的列表函数 ‘append’, ‘clear’, ‘copy’,’count’, ‘extend’, ‘index’, ‘insert’, ‘pop’, ‘remove’, ‘reverse’, ‘sort’ list.append(obj)在列表末尾添加新的对象,修改原对象且没有返回值123456a = [&quot;python&quot;, 1]print(a.append(2)) ---&gt; None # 没有返回值print(a) ---&gt; [&quot;python&quot;, 1,2]b=a.append([1, 2])print(b) ---&gt; None # 没有返回值print(a) ---&gt; [&quot;python&quot;, 1,[1,2]] list.extend(seq)在列表末尾一次性追加另一个序列中的多个值，修改原对象且没有返回值12345&gt;&gt;&gt; a = [&quot;python&quot;, 1]&gt;&gt;&gt; a.extend([1, 2])&gt;&gt;&gt; a ---&gt; [&quot;python&quot;, 1,1,2]&gt;&gt;&gt; a.extend(&apos;ab&apos;) # 当追加的是字符串时，字符串会以字符为单位拆开&gt;&gt;&gt; a ---&gt; [&quot;python&quot;, 1,1,2,&apos;a&apos;,&apos;b&apos;] list.insert(index,obj)将对象obj插入到列表中index位置，原位置向后移动。修改原对象且没有返回值123&gt;&gt;&gt; a = [&quot;python&quot;, 1]&gt;&gt;&gt; a.insert(1, &apos;a&apos;)&gt;&gt;&gt; a ---&gt; [&quot;python&quot;, &apos;a&apos;,1] list.copy()返回复制后的新列表，类似a[:] list.clear()清空列表，类似del a[:]，修改原对象且没有返回值 list.count(obj)返回某个元素在列表中出现的次数123&gt;&gt;&gt; a = [1, 2, 1, 1, 3]&gt;&gt;&gt; a.count(1) ---&gt; 3&gt;&gt;&gt; a.count(5) ---&gt; 0 # 可用该方法查找，没有也不会报错 list.index(obj)检索该元素在列表中第一次出现的位置。返回查找对象的索引位置，如果没有找到对象则抛出异常 list.pop([index])移除列表中的一个元素（默认最后一个元素），修改原对象并且返回该元素的值12345&gt;&gt;&gt; a = [&quot;python&quot;, 1, 1, 2]&gt;&gt;&gt; a.pop() ---&gt; 2&gt;&gt;&gt; a ---&gt; [&quot;python&quot;, 1, 1]&gt;&gt;&gt; a.pop(0) ---&gt; &apos;python&apos;&gt;&gt;&gt; a ---&gt; [1, 1, 2] list.remove(obj)移除列表中某个值的第一个匹配项。修改原对象且没有返回值，如果所删除的内容不在列表中，就报错。 list.reverse()将列表的元素顺序反过来。修改原对象且没有返回值123&gt;&gt;&gt; a = [3,5,1,6]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a ---&gt; [6, 1, 5, 3] 因为list.reverse()不返回值，所以不能实现对列表的反向迭代，如果要这么做，可以使用python内建的reversed(seq)函数。reversed(seq)函数可以反转一个list，返回一个迭代器（iterator） list.sort(key=None, reverse=False)key接受一个函数，这个函数只接受一个元素，默认为Nonereverse是一个布尔值。如果设置为True，列表元素将被倒序排列，默认为False修改原对象且没有返回值。默认情况，实现的是从小到大的排序。123&gt;&gt;&gt; a = [3,5,1,6]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; a ---&gt; [6, 5, 3, 1] python3内置函数sorted(iterable，key=None,reverse=False)可返回一个列表123&gt;&gt;&gt; students = [(&apos;john&apos;, &apos;A&apos;, 15), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;dave&apos;,&apos;B&apos;, 10)]&gt;&gt;&gt; sorted(students,key=lambda s: x[2]) #按照年龄来排序[(&apos;dave&apos;,&apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F106.html</url>
    <content type="text"><![CDATA[集合是一个无序 不重复可变元素集(但元素必须是不可变的元素)，主要用作去重和关系测试，和字典一样使用{}，所以创建空集合不用{}，用set() 创建集合12&gt;&gt;&gt; x = set(&apos;aabb&apos;)&gt;&gt;&gt; x --&gt; &#123;&apos;a&apos;, &apos;b&apos;&#125; 如果创建集合时有可变元素则会报错1234&gt;&gt;&gt; x = &#123;1,[1, 2]&#125;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; unhashable –&gt; 不可哈希 –&gt; 可变hashable –&gt; 可哈希 –&gt; 不可变 关系测试123456&gt;&gt;&gt; x = &#123;1, 2, 3&#125;&gt;&gt;&gt; y = &#123;2, 3, 4&#125;&gt;&gt;&gt; x | y --&gt; &#123;1, 2, 3, 4&#125; # 并集&gt;&gt;&gt; x &amp; y --&gt; &#123;2, 3&#125; # 交集&gt;&gt;&gt; x - y --&gt; &#123;1&#125; # 差集&gt;&gt;&gt; x ^ y --&gt; &#123;1, 4&#125; # 对称差集 常用集合方法add, update1234&gt;&gt;&gt; x = &#123;1, 2, 3&#125;&gt;&gt;&gt; x.add(&apos;abc&apos;)&gt;&gt;&gt; x --&gt; &#123;1, 2, 3, &apos;abc&apos;&#125;&gt;&gt;&gt; x.update(&apos;abc&apos;) --&gt; &#123;1, 2, 3, &apos;abc&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125; set.pop()随机删除元素并返回该元素，不存在则报错12&gt;&gt;&gt; x = &#123;1, 2, 3&#125;&gt;&gt;&gt; x.pop() --&gt; 1 set.remove(obj)删除指定元素，若集合中没有该元素则报错，修改原集合没有返回值123&gt;&gt;&gt; x = &#123;1, 2, 3&#125;&gt;&gt;&gt; x.remove(1)&gt;&gt;&gt; x --&gt; &#123;2, 3&#125; set.discard(obj)删除指定元素，集合中没有该元素不报错，修改原集合没有返回值1234&gt;&gt;&gt; x = &#123;1, 2, 3&#125;&gt;&gt;&gt; x.discard(1)&gt;&gt;&gt; x --&gt; &#123;2, 3&#125;&gt;&gt;&gt; x.discard(4) # do nothing set.clear()清空集合]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F105.html</url>
    <content type="text"><![CDATA[字典字典(dictionary)是另一种可变容器模型，且可存储任意类型对象，用dict()表示。字典的每个键值{key:value}对用冒号:分割，每个对之间用逗号,分割，整个字典包括在花括号{}中 键必须是唯一的，但值不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 基本操作字典对象是以键值对的形式存储数据的，所以只要知道键，就能得到值。这本质上就是一种映射关系。既然字典是键值对的映射，就不用考虑所谓“排序”问题了，只要通过键就能找到值，至于这个键值对位置在哪里就不用考虑了。没有排序也就不用索引和切片了 字典中的这类以键值对的映射方式存储数据，是一种非常高效的方法，比如要读取值得时候，如果用列表，Python需要从头开始读，直到找到指定的那个索引值。但是，在字典中是通过“键”来得到值。要高效得多。正是这个特点，键值对这样的形式可以用来存储大规模的数据，因为检索快捷。规模越大越明显。所以，mongdb这种非关系型数据库在大数据方面比较流行了。 len(d) 返回字典(d)中的键值对的数量12&gt;&gt;&gt; d = &#123;1: &apos;a&apos;, &apos;b&apos;: 2&#125;&gt;&gt;&gt; len(d) ---&gt; 2 d[key] 返回字典(d)中的键(key)的值12&gt;&gt;&gt; d = &#123;1: &apos;a&apos;, &apos;b&apos;: 2&#125;&gt;&gt;&gt; d[&apos;b&apos;] ---&gt; 2 d[key]=value，更新已有key的value或添加一对键值12345&gt;&gt;&gt; d = &#123;1:&apos;a&apos;,&apos;b&apos;:2&#125;&gt;&gt;&gt; d[1] = &apos;c&apos;&gt;&gt;&gt; d ---&gt; &#123;1:&apos;c&apos;,&apos;b&apos;:2&#125;&gt;&gt;&gt; d[3] = &apos;python&apos;&gt;&gt;&gt; d ---&gt; &#123;1: &apos;c&apos;, 3: &apos;python&apos;, &apos;b&apos;: 2&#125; del d[key]，删除字典(d)的键(key)项（将该键值对删除）123&gt;&gt;&gt; d = &#123;1:&apos;a&apos;,&apos;b&apos;:2&#125;&gt;&gt;&gt; del d[&apos;b&apos;]&gt;&gt;&gt; d ---&gt; &#123;1: &apos;a&apos;&#125; key in d，检查字典(d)中是否含有键为key的项123&gt;&gt;&gt; d = &#123;1:&apos;a&apos;,&apos;b&apos;:2&#125;&gt;&gt;&gt; &apos;b&apos; in d ---&gt; True&gt;&gt;&gt; &apos;c&apos; in d ---&gt; False 常用字典方法dict.copy()函数返回一个字典的浅复制， dict.clear()将字典清空(del是删除)，修改原对象，没有返回值 dict.get(key, default=None)返回指定键的值，如果值不在字典则返回默认值 dict.setdefault(key, default=None)返回指定键的值，如果值不在字典中则添加这对(key:default)没有返回值 items keys values123dict.items() # 以列表的`形式`返回可遍历的(键, 值) 元组数组dict.keys() # 以列表的`形式`返回字典所有的键dict.values() # 以列表的`形式`返回字典所有的值 返回的并不是list, 而是view对象 dict.pop(key,[,d])删除指定键的键值对，如果key不在字典中则返回d，如果key不在字典中又没有d，则报错 dict.update(dict2)更新原字典，没有返回值123456&gt;&gt;&gt; x = &#123;&apos;a&apos;:1&#125;&gt;&gt;&gt; y = &#123;&apos;b&apos;:2&#125;&gt;&gt;&gt; x.update(y)&gt;&gt;&gt; x --&gt; &#123;&apos;a&apos;:1, &apos;b&apos;:2&#125;&gt;&gt;&gt; z = [(&apos;c&apos;,3)] --&gt; 类似dict.items&gt;&gt;&gt; x.update(z)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F107.html</url>
    <content type="text"><![CDATA[python数据存储变量 引用 对象1x = 1 内存中只创建了对象1，变量x只是贴在对象1的标签，=是赋值即引用在python中一切皆对象，里面又有不可变对象和可变对象 数字和字符串对象引用1234567&gt;&gt;&gt; a = 5 # 内存中创建了一个对象5&gt;&gt;&gt; b = 5&gt;&gt;&gt; b --&gt; 5&gt;&gt;&gt; id(a) --&gt; 139774080&gt;&gt;&gt; id(b) --&gt; 139774080 # 一个对象贴了两个标签&gt;&gt;&gt; b = 3 # 内存中新建了一个对象3&gt;&gt;&gt; id(b) --&gt; 10923616 # 对象引用换成了b 组合对象的引用(除了数字和字符串) 可以创建多个”一样”的对象,但是id不同1234567&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; id(x) --&gt; 140150136275912&gt;&gt;&gt; y = x[:]&gt;&gt;&gt; y --&gt; [1, 2, 3]&gt;&gt;&gt; id(y) --&gt; 140150136287496&gt;&gt;&gt; z = [1, 2, 3]&gt;&gt;&gt; id(z) --&gt; 140150136287944 解析:123456789&gt;&gt;&gt; x = &apos;a&apos;&gt;&gt;&gt; y = [&apos;a&apos;, 1, [&apos;a&apos;, 1]]&gt;&gt;&gt; id(x) --&gt; 140363897810368 # 对象&apos;a&apos;&gt;&gt;&gt; id(y) --&gt; 140363897692872 # 列表对象&gt;&gt;&gt; id(y[0]) --&gt; 140363897810368&gt;&gt;&gt; id(y[1]) --&gt; 10923552 # 列表的子对象数字1&gt;&gt;&gt; id(y[2]) --&gt; 140363897680840 # 列表子对象列表[&apos;a&apos;, 1]&gt;&gt;&gt; id(y[2][0]) --&gt; 140363897810368 # 三个 &apos;a&apos; id一样&gt;&gt;&gt; id(y[2][1]) --&gt; 10923552 # 两个 1 id一样 修改列表内容：123&gt;&gt;&gt; y.remove([&apos;a&apos;, 1])&gt;&gt;&gt; y --&gt; [&apos;a&apos;, 1]&gt;&gt;&gt; id(y) --&gt; 140363897692872 # 因为是修改原对象，所有id不变 可变对象的浅拷贝123456789&gt;&gt;&gt; x = &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125; # 最底层的对象只有1,2,3&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y --&gt; &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125;&gt;&gt;&gt; id(x) --&gt; 139791973166088&gt;&gt;&gt; id(y) --&gt; 139791973166024 # 父对象id显示不一样&gt;&gt;&gt; id(x[&apos;a&apos;]) --&gt; 10923552&gt;&gt;&gt; id(y[&apos;a&apos;]) --&gt; 10923552 # 子对象id一样&gt;&gt;&gt; id(x[&apos;b&apos;]) --&gt; 139791972639688&gt;&gt;&gt; id(y[&apos;b&apos;]) --&gt; 139791972639688 # 子对象id一样 从上面可以看出，浅复制只是创建一个新的父对象，子对象还是同一个对象 修改字典的列表1234567&gt;&gt;&gt; id(y[&apos;b&apos;][1]) --&gt; 10923584&gt;&gt;&gt; y[&apos;a&apos;] = 2 # 引用对象2&gt;&gt;&gt; id(y[&apos;a&apos;]) --&gt; 10923584&gt;&gt;&gt; y[&apos;b&apos;].remove(2)&gt;&gt;&gt; id(y[&apos;b&apos;]) --&gt; 139791972639688 # 列表子对象id没有改变&gt;&gt;&gt; y --&gt; &#123;&apos;b&apos;: [1, 3], &apos;a&apos;: 1&#125;&gt;&gt;&gt; x --&gt; &#123;&apos;b&apos;: [1, 3], &apos;a&apos;: 1&#125; 导入copy模块实现deep copy123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; x = &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125;&gt;&gt;&gt; y = copy.copy(x) # 浅拷贝和前面一样&gt;&gt;&gt; z = copy.deepcopy(x) # 深拷贝&gt;&gt;&gt; id(x[&apos;b&apos;]) --&gt; 140541619106696&gt;&gt;&gt; id(z[&apos;b&apos;]) --&gt; 140541618998536 # 创建了两个列表对象&gt;&gt;&gt; z[&apos;b&apos;].remove(2)&gt;&gt;&gt; x --&gt; &#123;&apos;a&apos;: 1, &apos;b&apos;: [1, 2, 3]&#125;&gt;&gt;&gt; z --&gt; &#123;&apos;a&apos;: 1, &apos;b&apos;: [1, 3]&#125; deepcopy可以创建两个id不一样的可变对象，但不影响不可变对象 变量python引用变量的顺序： 当前作用域局部变量-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量global和nonlocal12345a = 1 # 全局变量，可省略global关键字def y(): a = a + 1 # 全局变量可以在函数内部使用，但不能修改y() # 报错 变量解析规则在python的作用域规则里面，创建变量一定会在当前作用域里创建一个变量，但是访问或者修改变量时会先在当前作用域查找变量，没有找到匹配变量的话会依次向上在闭合的作用域里面进行查看找 声明全局变量，如果在局部要对全局变量修改，需要在局部也要先声明该全局变量 在局部如果不声明全局变量，并且不修改全局变量。则可以正常使用全局变量 nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量 避免出错的办法，就是尽量不重复使用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F108.html</url>
    <content type="text"><![CDATA[列表相减解法一:用for循环123456789x = [1, 2, 3, 3, 2, 1]y = [1, 4]z = []for i in x: if i on in y: z.append(i)print(z) #--&gt; [2, 3, 3, 2] 解法二:用列表解析1234&gt;&gt;&gt; x = [1, 2, 3, 3, 2, 1]&gt;&gt;&gt; y = [1, 4]&gt;&gt;&gt; z = [i for i in x if i not in y]&gt;&gt;&gt; z #--&gt; [2, 3, 3, 2]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F122.html</url>
    <content type="text"><![CDATA[if条件语句基本语法:12if bool(conj): # 如果if后面的条件满足，则执行后面的语句块 do something # 统一缩进4个空格 if … elif … else基本样式结构：123456789if 条件1: # 满足条件1则执行语句块1 语句块1elif 条件2: # 满足条件2则执行语句块2 语句块2elif 条件3： 语句块3...else: # 上面条件都都不满足才执行 语句块4 三元操作符12345&gt;&gt;&gt; x = -1&gt;&gt;&gt; y = 1 if x &gt; 0 else 2&gt;&gt;&gt; y --&gt; 2&gt;&gt;&gt; x = 2&gt;&gt;&gt; y --&gt; 1]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F121.html</url>
    <content type="text"><![CDATA[语句一般所有高级语言，都包含如下语句，Python也不例外： 循环语句:容许一些语句反复运行数次。循环可依据一个默认的数目来决定运行这些语句的次数；或反复运行它们，直至某些条件改变。 条件语句:容许仅当某些条件成立时才运行某个区块。否则，这个区块中的语句会略去，然后按区块后的语句继续运行。 无条件分支语句容许运行顺序转移到程序的其他部分之中。包括跳跃（在很多语言中称为Goto）、副程序和Procedure等。 循环、条件分支和无条件分支都是控制流程。 import导入模块12&gt;&gt;&gt; import math # 可读性强&gt;&gt;&gt; math.pow(3,2) --&gt; 9.0 导入模块中单个或多个方法1234&gt;&gt;&gt; from math import pow # 可读性差&gt;&gt;&gt; from math import e, pi&gt;&gt;&gt; pow(3,2) --&gt; 9.0&gt;&gt;&gt; pow(e,pi) --&gt; 23.140692632779263 导入模块中的函数并自定义名称12&gt;&gt;&gt; from math import pow as pingfang&gt;&gt;&gt; pingfang(3,2) --&gt; 9.0 导入模块中的所有方法12345&gt;&gt;&gt; from math import *&gt;&gt;&gt; pow(3,2)9.0&gt;&gt;&gt; sqrt(9)3.0 赋值语句 编程中的“=”和数学中的“=”是完全不同的。在编程语言中，“=”表示赋值过程。 多重赋值语句1234&gt;&gt;&gt; x, y, z = 1, &quot;python&quot;, [&quot;hello&quot;, &quot;world&quot;]&gt;&gt;&gt; x --&gt; 1&gt;&gt;&gt; y --&gt; &apos;python&apos;&gt;&gt;&gt; z --&gt; [&apos;hello&apos;, &apos;world&apos;] 变量值互换12345&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = 9&gt;&gt;&gt; a, b = b, a # 相当于标签互换&gt;&gt;&gt; a --&gt; 9&gt;&gt;&gt; b --&gt; 2 还有一种赋值方式，被称为“链式赋值”123&gt;&gt;&gt; m = n = &quot;python&quot;&gt;&gt;&gt; m --&gt; &quot;python&quot;&gt;&gt;&gt; n --&gt; &quot;python&quot;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F123.html</url>
    <content type="text"><![CDATA[for循环其基本结构是：12for 循环规则： # 冒号:结束 操作语句 # 缩进四个空格 字符串for循环：123456789&gt;&gt;&gt; hello = &quot;world&quot;&gt;&gt;&gt; for i in hello: # 冒号:结束... print(i) # print自带end=&apos;\n&apos;... world 循环的对象必须是可迭代的对象，判断是否存在:12&gt;&gt;&gt; &apos;__iter__&apos; in dir(1) --&gt; False&gt;&gt;&gt; &apos;__iter__&apos; in dir(list) --&gt; True range(start,stop[, step]) –&gt; range object start：开始数值，缺省则为0 stop：结束的数值，必须要写，取值为stop-1 step：变化的步长，缺省则为1 stop&gt;start : step&gt;0(非必须) stop&lt;start : step&lt;0(非必须) while循环12while 判断条件: # 冒号:结束 语句 # 缩进4个空格 break语句跳出 for 和 while 的循环体 continue语句跳过当前循环块中的剩余语句，然后继续进行下一轮循环 pass语句空语句，是为了保持程序结构的完整性，pass不做任何事情，一般用做占位语句]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F124.html</url>
    <content type="text"><![CDATA[并行迭代迭代两个以上的集合 zip(iter1 [,iter2 […]]) –&gt; zip object问题:多个矩阵元素互换12345678&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = [4, 5, 6]&gt;&gt;&gt; z = [7, 8, 9]&gt;&gt;&gt; xyz = list(zip(x, y, z))&gt;&gt;&gt; xyz #--&gt; [(1, 4, 7), (2, 5, 8), (3, 6, 9)]&gt;&gt;&gt; zyx = list(zip(*xyz)) # 参数加*解压&gt;&gt;&gt; zyx #--&gt; [(1, 2, 3), (4, 5, 6), (7, 8, 9)] 问题：有两个列表，分别是：a = [1, 2, 3, 4, 5], b = [9, 8, 7, 6, 5]，要计算这两个列表中对应元素的和。方法一:1234567&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; b = [9, 8, 7, 6, 5]&gt;&gt;&gt; c = []&gt;&gt;&gt; for i in range(len(a)):... c.append(a[i]+b[i])... &gt;&gt;&gt; c #--&gt; [10, 10, 10, 10, 10] 方法二:12345&gt;&gt;&gt; d = []&gt;&gt;&gt; for x,y in zip(a,b):... d.append(x+y)... &gt;&gt;&gt; d #--&gt; [10, 10, 10, 10, 10] 用列表解析:1234&gt;&gt;&gt; x = [a[i]+b[i] for i in range(len(a))]&gt;&gt;&gt; x #--&gt; [10, 10, 10, 10, 10]&gt;&gt;&gt; y = [x+y for x,y in zip(a,b)]&gt;&gt;&gt; y #--&gt; [10, 10, 10, 10, 10] 问题:字典键值互换用for循环:123456&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; m = &#123;&#125;&gt;&gt;&gt; for k, v in d.items():... m[v] = k # 以v为key,以k为values添加键值对...&gt;&gt;&gt; m #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125; 因为字典有items方法,而zip只能获得key:12&gt;&gt;&gt; x = dict(zip(d.values(),d.keys()))&gt;&gt;&gt; x #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125; 用dict解析:12&gt;&gt;&gt; y = &#123;v:k for k, v in d.items()&#125;&gt;&gt;&gt; y #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F126.html</url>
    <content type="text"><![CDATA[文件打开文件1open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opene r=None) 模式 描述 r 以读方式打开文件，可读取文件信息,默认模式 w 以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容 x 以写模式新建一个文件 a 以追加模式打开文件（文件指针自动移到文件末尾），如果文件不存在则创建 + 配合其他模式r,w,a等,以读和写模式 b 二进制模式 12&gt;&gt;&gt; f = open(&quot;130.txt&quot;) # 在当前文件夹打开已存在的文件&gt;&gt;&gt; dir(f) 在对文件进行写入操作之后，一定要牢记一个事情：file.close() with…as…用with语句不用关闭文件123&gt;&gt;&gt; with open(&quot;130.txt&quot;,&quot;a&quot;) as f:... f.write(&quot;\nThis is about &apos;with...as...&apos;&quot;)... 常用文件方法f.read([size])如果指定了参数size，就按照该指定长度从文件中读取内容，否则，就读取全文直到EOF f.readline([size]) 如果指定了参数size,则读取指定长度的内容,直到行尾才会读取下一行 如果不指定参数,则一行一行读取 f.readlines([hint]) 返回该文件中包含的所有行。 如果设置可选参数hint, 则读取指定长度的字节, 并且将这些字节按行分割 EOF(End-of-file) f.write(string)将 string 写入到文件中, 然后返回写入的字符数 f.tell()返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数 f.seek(offset[, whence])这个函数的功能就是让指针移动。whence的值： 默认值是0，表示从文件开头开始计算指针偏移的量（简称偏移量）。此时offset必须是大于等于0的整数。 是1时，表示从当前位置开始计算偏移量。offset如果是负数，表示从当前位置向前移动，整数表示向后移动。 是2时，表示相对文件末尾移动。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F128.html</url>
    <content type="text"><![CDATA[在使用Python的过程中，很容易混淆如下几个关联的概念： 容器(container) 可迭代对象(Iterable) 迭代器(Iterator) 生成器(generator) list, set, dict解析式 生成器表达式 容器（container)容器是用来储存元素的一种数据结构，它支持隶属测试，容器将所有数据保存在内存中，在Python中典型的容器有： list， deque, … set，frozesets，… dict, defaultdict, OrderedDict, Counter, … tuple, namedtuple, … str 用in,not in判断是否存在,字典容器通过检查是否包含键来进行判断,字符串通过检查是否包含某个子串来判断123&gt;&gt;&gt; 1 in [1,2,3] #--&gt; True&gt;&gt;&gt; 4 in [1,2,3] #--&gt; False&gt;&gt;&gt; 4 not in [1,2,3] #--&gt; True 注意：并非所有的容器都是可迭代对象。 可迭代对象正如前面所提到的，大部分容器都是可迭代的，但是还有其他一些对象也可以迭代，例如，文件对象以及管道对象等等123456&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; y = iter(x）&gt;&gt;&gt; next(y) #--&gt; 1&gt;&gt;&gt; next(y) #--&gt; 2&gt;&gt;&gt; type(x) #--&gt; &lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(y) #--&gt; &lt;class &apos;list_iterator&apos;&gt; 在这里，x是可迭代对象。而y是迭代器，可以从可迭代对象x中获取值。 注意：可迭代的类中，一般实现以下两个方法，__iter__()以及__next()__方法，__iter__()方法返回self。 实际调用过程如下： 迭代器(Iterators) 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从第一个元素开始访问，直到所有的元素被访问完结束。 迭代器只能往前不会后退。 迭代器有两个基本的方法：__iter__() 和 __next__() itertools模块1234&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start=13)&gt;&gt;&gt; next(counter) --&gt; 13&gt;&gt;&gt; next（counter) --&gt; 14 无限序列：123456&gt;&gt;&gt; from itertools import cycle&gt;&gt;&gt; colors = cycle([&quot;red&quot;,&quot;white&quot;,&quot;blue&quot;])&gt;&gt;&gt; next(colors) --&gt; &quot;red&quot;&gt;&gt;&gt; next(colors） --&gt; &quot;white&quot;&gt;&gt;&gt; next(colors) --&gt; &quot;blue&quot;&gt;&gt;&gt; next(colors) --&gt; &quot;red&quot; 无限序列生成有限序列：123456789&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; colors = cycle([&apos;red&apos;, &apos;white&apos;, &apos;blue&apos;]) # infinite&gt;&gt;&gt; limited = islice(colors, 0, 4) # finite&gt;&gt;&gt; for x in limited: # so safe to use for-loop on... print(x)redwhitebluered 生成器(generator)带有yield关键字的的函数在Python中被称之为 generator(生成器)。一个函数或者子程序都只能return一次，但是一个生成器能暂停执行并返回一个中间的结果。 生成器其实就是一种特殊的迭代器 生成器的另一个优点就是无须将对象的所有元素都存入内存之后，才开始进行操作。生成器仅在迭代至某个元素时才会将该元素放入内存，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的类序列对象，EG. 大文件/大集合/大字典/斐波那契数列等。这个特点被称为 延迟计算 或 惰性求值(Lazy evaluation)，可以有效的节省内存。 list解析式12[expr for iter_var in iterable] # 最终生成一个列表[expr][expr for iter_var in iterable if cond_expr] 代码实例：12345&gt;&gt;&gt; x = [(x+1,y+1) for x in range(2) for y in range(3)] &gt;&gt;&gt; x #--&gt; [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]&gt;&gt;&gt; y = [x+10 for x in range(10) if x&gt;5]&gt;&gt;&gt; y #--&gt; [16, 17, 18, 19] 还有集合解析，类似列表解析，区别在于结果满足集合的特性 dict解析式123&gt;&gt;&gt; x = &#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4&#125;&gt;&gt;&gt; y = &#123;v:k for k,v in x.items()&#125;&gt;&gt;&gt; y #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125; 生成器表达式12(expr for iter_var in iterable)(expr for iter_var in iterable if cond_expr) 当序列过长，而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被()括起来的，而不是[]1234567891011&gt;&gt;&gt; y = (x+10 for x in range(10) if x&gt;5)&gt;&gt;&gt; y&lt;generator object &lt;genexpr&gt; at 0x7faeee369d58&gt;&gt;&gt;&gt; y.__next__() #--&gt; 16&gt;&gt;&gt; y.__next__() #--&gt; 17&gt;&gt;&gt; y.__next__() #--&gt; 18&gt;&gt;&gt; y.__next__() #--&gt; 19&gt;&gt;&gt; y.__next__()StopIteration Traceback (most recent call last)&lt;ipython-input-18-989149fd7263&gt; in &lt;module&gt;()----&gt; 1 y.__next__() 生成器表达式并不真正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”(yield)出来。 生成器表达式使用了“惰性计算”(lazy evaluation)，只有在检索时才被赋值 (evaluated)，所以在列表比较长的情况下使用内存上更有效。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F130.html</url>
    <content type="text"><![CDATA[自省 来源《Python自省指南》 联机帮助在交互模式下，用help向python请求帮助。1234567891011121314151617&gt;&gt;&gt; help()Welcome to Python 3.5&apos;s help utility!If this is your first time using Python, you should definitely check outthe tutorial on the Internet at http://docs.python.org/3.5/tutorial/.Enter the name of any module, keyword, or topic to get help on writingPython programs and using Python modules. To quit this help utility andreturn to the interpreter, just type &quot;quit&quot;.To get a list of available modules, keywords, symbols, or topics, type&quot;modules&quot;, &quot;keywords&quot;, &quot;symbols&quot;, or &quot;topics&quot;. Each module also comeswith a one-line summary of what it does; to list the modules whose nameor summary contain a given string such as &quot;spam&quot;, type &quot;modules spam&quot;.help&gt; 这时候就进入了联机帮助状态，根据提示输入keywords12345678910111213help&gt; keywordsHere is a list of the Python keywords. Enter any keyword to get more help.False def if raiseNone del import returnTrue elif in tryand else is whileas except lambda withassert finally nonlocal yieldbreak for notclass from orcontinue global pass 如果从文档说明界面返回到帮助界面，需要按q键。从联机帮助状态退回到python的交互模式，使用quit命令。 dir()dir() 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则 dir() 返回当前作用域中的名称。让我们将 dir() 函数应用于 keyword 模块，并观察它揭示了什么：123456&gt;&gt;&gt; import keyword&gt;&gt;&gt; dir(keyword)[&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;iskeyword&apos;, &apos;kwlist&apos;, &apos;main&apos;]&gt;&gt;&gt; __builtins__&lt;module &apos;__builtin__&apos; (built-in)&gt; 注：如果您在磁盘上寻找 __builtin__.py 文件，将空手而归。这个特殊的模块对象是 Python 解释器凭空创建的，因为它包含着解释器始终可用的项。尽管看不到物理文件，但我们仍可以将 dir() 函数应用于这个对象，以观察所有内置函数、错误对象以及它所包含的几个杂项属性。12&gt;&gt;&gt; dir(__builtins__)[省略...... &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;ascii&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;ngettext&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] dir() 函数适用于所有对象类型，包括字符串、整数、列表、元组、字典、函数、定制类、类实例和类方法 dir(42),dir([]),dir(()),dir({}),dir(dir) 检查python对象在计算机术语中，对象是拥有标识和值的事物，属于特定类型、具有特定特征和以特定方式执行操作。并且，对象从一个或多个父类继承了它们的许多属性。除了关键字和特殊符号（像运算符，如 + 、 - 、 、 * 、 / 、 % 、 &lt; 、 &gt; 等）外，Python 中的所有东西都是对象。Python具有一组丰富的对象类型：字符串、整数、浮点、列表、元组、字典、函数、类、类实例、模块、文件等。 当您有一个任意的对象（也许是一个作为参数传递给函数的对象）时，可能希望知道一些关于该对象的情况。如希望python告诉我们： 对象的名称是什么？ 这是哪种类型的对象？ 对象知道些什么？ 对象能做些什么？ 对象的父对象是谁？ 文档字符串__doc__属性__doc__ 这个属性是一个字符串，它包含了描述对象的注释。Python 称之为文档字符串或docstring如果模块、类、方法或函数定义的第一条语句是字符串，那么该字符串会作为对象的 __doc__ 属性与该对象关联起来。例如，看一下str类型对象的文档字符串。 名称__name__属性 如果模块是被导入，__name__的值为模块名字 如果是被直接执行，__name__的值为__main__ 此处所说的模块可以简单理解为一个.py文件 并非所有对象都有名称，但那些有名称的对象都将名称存储在其 __name__ 属性中。注：名称是从对象而不是引用该对象的变量中派生的。 12345678if __name__ == &apos;__main__&apos;: # Do something appropriate here, like calling a # main() function defined elsewhere in this module. main()else: # Do nothing. This module has been imported by another # module that wants to make use of the functions, # classes and other useful bits it has defined. 类型type()1234&gt;&gt;&gt; type(42) #--&gt; &lt;type &apos;int&apos;&gt;&gt;&gt;&gt; type([]) #--&gt; &lt;type &apos;list&apos;&gt;&gt;&gt;&gt; type(&#123;&#125;) #--&gt; &lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; type(dir) #--&gt; &lt;type &apos;builtin_function_or_method&apos;&gt; 标识id()检测是否存在属性in/not in可调用callable() callable()方法用来检测对象是否可被调用，可被调用指的是对象能否使用()括号的方法调用。 可调用对象，在实际调用也可能调用失败；但是不可调用对象，调用肯定不成功。 类对象都是可被调用对象，类的实例对象是否可调用对象，取决于类是否定义了call方法。 实例在 type() 函数提供对象的类型时，还可以使用 isinstance() 函数测试对象，以确定它是否是某个特定类型或定制类的实例： 子类关于类的问题，有一个“继承”概念，有继承就有父子问题，这是在现实生活中很正常的，在编程语言中也是如此。虽然这是后面要说的，但是，为了本讲内容的完整，也姑且把这个内容放在这里。读者可以不看，留着以后看也行。我更建议还是阅读一下，有个印象。 在类这一级别，可以根据一个类来定义另一个类，同样地，这个新类会按照层次化的方式继承属性。Python 甚至支持多重继承，多重继承意味着可以用多个父类来定义一个类，这个新类继承了多个父类。 issubclass() 函数使我们可以查看一个类是不是继承了另一个类： python文档1.文档是一种对软件系统的书面描述；2.文档应当精确地描述软件系统；3.软件文档是软件工程师之间用作沟通交流的一种方式；4.文档的类型有很多种，包括软件需求文档，设计文档，测试文档，用户手册等；5.文档的呈现方式有很多种，可以是传统的书面文字形式或图表形式，也可是动态的网页形式 python文档的网址：https://docs.python.org/2/，这是python2.x，从这里也可以找到python3.x的文档。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F202.html</url>
    <content type="text"><![CDATA[built-in function&gt;&gt;&gt; dir(__builtins__) [...省略... &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;ascii&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;exec&apos;, &apos;exit&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;vars&apos;, &apos;zip&apos;] 常用内建函数[&apos;dir&apos;, &apos;format&apos;, &apos;help&apos;, &apos;id&apos;, &apos;input&apos;, &apos;open&apos;, &apos;print&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;type&apos;, &apos;input&apos;, &apos;zip&apos;] 数学相关[&apos;abs&apos;, &apos;len&apos;, &apos;max&apos;, &apos;min&apos;, &apos;pow&apos;, &apos;round&apos;, &apos;reversed&apos;, &apos;sorted&apos;, &apos;sum&apos;, &apos;divmod&apos;] 数据类型[&apos;bool&apos;, &apos;complex&apos;, &apos;dict&apos;, &apos;list&apos;, &apos;str&apos;, &apos;int&apos;, &apos;float&apos;, &apos;tuple&apos;, &apos;set&apos;, &apos;iter&apos;] 函数式编程[&apos;filter&apos;, &apos;map&apos;] 0-255与相应ascii码转换[&apos;chr&apos;, &apos;ord&apos;] 进制转换[&apos;bin&apos;, &apos;hex&apos;, &apos;oct&apos;] 类相关[&apos;callable&apos;, &apos;classmethod&apos;, &apos;delattr&apos;, &apos;getattr&apos;, &apos;hasattr&apos;, &apos;issubclass&apos;, &apos;isinstance&apos;, &apos;setattr&apos;, &apos;staticmethod&apos;, &apos;super&apos;] 变量相关[&apos;globals&apos;, &apos;locals&apos;, &apos;vars&apos;] 内建函数简介 abs() 获取绝对值 all() 接受一个迭代器，如果迭代器的所有元素都为真，那么返回True，否则返回False any() 接受一个迭代器，如果迭代器里有一个元素为真，那么返回True,否则返回False ascii() 调用对象的repr()方法，获得该方法的返回值. bin() 将十进制数分别转换为2进制 oct() 将十进制数分别转换为8进制 hex() 将十进制数分别转换为16进制。 bool() 测试一个对象是True还是False. bytes() 将一个字符串转换成字节类型 str() 将字符类型/数值类型等转换为字符串类型 challable() 判断对象是否可以被调用，能被调用的对象就是一个callables对象，比如函数和带有call()的实例 char()，13. ord() 查看十进制数对应的ASCII字符/查看某个ASCII对应的十进制数 classmethod() 用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法 complie() 将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译 complex() delattr() 删除对象的属性 dict() 创建数据字典 dir() 不带参数时返回当前范围内的变量，方法和定义的类型列表，带参数时返回参数的属性，方法列表 divmod() 分别取商和余数 enumerate() 返回一个可以枚举的对象，该对象的next()方法将返回一个元组 eval() 将字符串str当成有效的表达式来求值并返回计算结果 exec() 执行字符串或complie方法编译过的字符串，没有返回值 filter() 过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据 float() 讲一个字符串或整数转换为浮点数 format() 格式化输出字符串 frozenset() 创建一个不可修改的集合 getattr() 获取对象的属性 globals() 返回一个描述当前全局变量的字典 hasattr() 判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object，name)）是否抛出异常来实现的。 hash() 哈希值 help() 返回对象的帮助文档 id() 返回对象的内存地址 input() 获取用户输入内容 int() 将一个字符串或数值转换为一个普通整数 isinstance() 检查对象是否是类的对象，返回True或False issubclass() 检查一个类是否是另一个类的子类。返回True或False iter() 返回一个iterator对象 len() 返回对象长度 list() 列表构造函数 locals() 打印当前可用的局部变量的字典 map(function, iterable,…) 对于参数iterable中的每个元素都应用fuction函数，并将结果作为列表返回。 max() 返回给定元素里最大值 min() 返回给定元素里最小值 next() 返回一个可迭代数据结构（如列表）中的下一项 object() 获取一个新的，无特性(geatureless)对象。Object是所有类的基类。它提供的方法将在所有的类型实例中共享。 open() 打开文件 pow() 幂函数 property() range() 根据需要生成一个指定范围的数字，可以提供你需要的控制来迭代指定的次数 repr() 将任意值转换为字符串，供计时器读取的形式 reversed() 反转，逆序对象 round() 四舍五入 set() 集合构造函数 setattr() 与getattr()相对应 slice() 切片功能 sorted() 排序 staticmethod() str() 字符串构造函数 sum() 求和 super() 调用父类的方法 tuple() 元组构造函数 type() 显示对象所属的类型 vars() 返回 __dict__ 属性, 比如模块, 类, 实例, 或者其他 带有 __dict__ 属性的 object zip() 将对象逐一配对]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F204.html</url>
    <content type="text"><![CDATA[递归 递归（recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。 根据斐波那契数列的定义，可以直接写成这样的斐波那契数列递归函数。12345678910111213141516#!/usr/bin/env python3# coding=utf-8def fib(n): &quot;&quot;&quot; This is Fibonacci by Recursion. &quot;&quot;&quot; if n==0: return 0 elif n==1: return 1 else: return fib(n-1) + fib(n-2)n = int(input(&apos;输入正整数:&apos;))print(fib(n)) 解析当n = 4时：12345fib(4) = fib(3) + fib(2) ↓ ↓ fib(2) + fib(1) fib(1) + fib(0) ↓ fib(1) + fib(0) 相当于fib(4) = 3fib(1) + 2fib(0) -&gt; 3 上面的代码每次递回下一级函数，都要判断一次判断一次if和elif 相当于 优化代码123456789101112#!/usr/bin/env python# coding=utf-8d = &#123;0:0, 1:1&#125; def fib(n): if not n in d: d[n] = fib(n-1) + fib(n-2) return d[n]n = int(input(&apos;输入正整数:&apos;))print(d(n)) 用递归函数要小心，因为很容易陷入死循环]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F237.html</url>
    <content type="text"><![CDATA[Python是支持多种范型的语言，可以进行所谓函数式编程，其突出体现在有这么几个函数：filter、map、reduce、lambda、yield。 匿名函数lambda 在lambda后面直接跟变量 变量后面是冒号 冒号后面是表达式，表达式计算结果就是本函数的返回值 123lambda x: x * x #--&gt; def func(x): return(x*x)lambda x: x%2lambda x, y: (x, y) #--&gt; def f(x, y): return (x, y) map(function, iterable[,iterable2])原理是: iterable的数量必须和function的参数一致 按顺序一一对应从可迭代对象传入参数3.函数返回的值是一个以list的形式的map对象 1234567&gt;&gt;&gt; lst1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; lst2 = [6, 7, 8, 9, 0]&gt;&gt;&gt; lst3 = [7, 8, 9, 2, 1]&gt;&gt;&gt; x = map(lambda x,y,z: x+y+z, lst1, lst2, lst3) #--&gt; &lt;map object at 0x7f2a502419e8&gt;&gt;&gt;&gt; list(x) #--&gt; [14, 17, 20, 15, 6]&gt;&gt;&gt; y = [x+y+z for x, y, z in zip(lst1, lst2, lst3)]&gt;&gt;&gt; y #--&gt; [14, 17, 20, 15, 6] reduce12&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y: x*y,[1, 2, 3, 4, 5]) #--&gt; 120 filter1234&gt;&gt;&gt; numbers = range(-2,3)&gt;&gt;&gt; numbers #--&gt; [-2, -1, 0, 1, 2]&gt;&gt;&gt; filter(lambda x: x&gt;0, numbers) #--&gt; [1, 2]&gt;&gt;&gt; [x for x in numbers if x&gt;0] #--&gt; [1, 2]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F401.html</url>
    <content type="text"><![CDATA[构造和初始化new(cls, […) new 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法。 new 方法相当不常用,但是它有自己的特性，特别是当继承一个不可变的类型比如一个tuple或者string。 init(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。 调用 x = SomeClass(10, ‘foo’)，那么 init 将会得到两个参数10和foo。 del(self) 如果 new 和 init 是对象的构造器的话，那么 del 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.del() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 del 能够被执行，所以 del can’t serve as a replacement for good coding practices ()~~ 特殊属性调用机制 类属性调用原理目的 所编写代码 Python 实际调用类构造器x = MyClass() –&gt; x.new()类析构器del x –&gt; x.del()只定义特定集合的某些属性x.slots()自定义散列值hash(x) x.hash()获取某个属性的值x.color type(x).dict[‘color’].get(x, type(x))设置某个属性的值x.color = ‘PapayaWhip’ type(x).dict[‘color’].set(x, ‘PapayaWhip’)删除某个属性del x.color type(x).dict[‘color’].del(x)控制某个对象是否是该对象的实例your class isinstance(x, MyClass) MyClass.instancecheck(x)控制某个类是否是该类的子类issubclass(C, MyClass) MyClass.subclasscheck(C)控制某个类是否是该抽象基类的子类issubclass(C, MyABC) MyABC.subclasshook(C) __getattr__() 和 __getattribute__()文件中的__main__.py 和 __init__.pypython3 xxx.py python3 -m xxx.py 这是两种加载py文件的方式: 叫做直接运行 相当于import,叫做当做模块来启动，前提是已加入sys.path python 将一个文件夹作为 package 对待，那么这个文件夹中必须包含一个名为 init.py 的文件，即使它是空的如果你需要 python 讲一个文件夹作为 package 执行，那么这个文件夹中必须包含一个名为 main.py 的文件，当执行 python3 -m hhlb 或者python3 hhlb 的时候，这个文件中的代码都会被执行。 在 hhlb/init.py 中写入如下内容：123print(&apos;__init__&apos;)print(&apos;__init__.__name__&apos;, __name__)print(&apos;__init__.__package__&apos;, __package__) 在 hhlb/main.py 中写入如下内容：123print(&apos;__main__&apos;)print(&apos;__main__.__name__&apos;, __name__)print(&apos;__main__.__package__&apos;, __package__) 执行 python3 hhlb ：1234-&gt; % python3 hhlb__main____main__.__name__ __main____main__.__package__ 这说明，将 hhlb 当作文件夹执行的时候，对于 main.py 来说，变量package 是一个空字符串。而 init.py 不会被执行。 执行 python3 -m hhlb ：1234567-&gt; % python3 -m hhlb__init____init__.__name__ hhlb__init__.__package__ hhlb__main____main__.__name__ __main____main__.__package__ hhlb 当作为模块执行的时候，python 会先执行 init.py ，然后执行main.py 。而且，前者和后者对于 name 变量的理解是不同的。 alll对于from ModuleName import * 这种形式，要特别注意重名现象。 Python中，对于一个模块，具有一个名为 all的属性，该属性的值就是被from ModuleName import *这样的语句绑定的属性列表；否则，这种类型的from语句将绑定模块中除了以下划线开始的属性（私有属性）外的所有属性。这样的话，对于同一个名空间里 面出现重名现象的概率就加大了，为了减少这种情况的发生，都会在模块开始处定义all属性的内容，写出可以被这种from类型导入的属性下面的是os.py里面的一段代码：all = [“altsep”, “curdir”, “pardir”, “sep”, “pathsep”, “linesep”,”defpath”, “name”, “path”, “devnull”] 其他globals:global namespace in which this function was definedfile:filename (missing for built-in modules) 内建特殊属性用dir(__builtins__)查看内建特殊属性，特殊属性都是以双下划线开头和结尾1&apos;__build_class__&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos; inspect模块type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.12import inspectdir(inspet) inspect.getmembers()12345Help on function getmembers in module inspect:getmembers(object, predicate=None) Return all members of an object as (name, value) pairs sorted by name. Optionally, only return members that satisfy a given predicate.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Findex.html</url>
    <content type="text"><![CDATA[Python3学习笔记 Python3学习笔记 第壹章 基本数据类型 python3基本语法 字符串 列表 元组 字典 集合 数据存储原理 实战 第贰章 语句和文件 语句 ==&gt; import, 赋值语句、增量赋值 条件语句 ==&gt; if…elif…else语句，三元操作 循环语句 ==&gt; for、while循环，break、continue语句，range() 迭代 ==&gt; 可迭代对象、迭代器、生成器、列表解析 并行迭代 ==&gt; for循环 vs zip() 文件 ==&gt; 文件打开，读取，写入，常用方法 自省 ==&gt; help()，dir()，文档字符串，检查对象，文档 第叁章 函数 函数==&gt;定义函数方法，调用函数方法，参数 内建函数 递归==&gt;递归、传递函数、嵌套函数 闭包、装饰器 函数5==&gt;filter、map、reduce、lambda 命名空间==&gt;全局变量和局部变量，作用域，命名空间 第肆章 类 特殊属性==&gt;内建和特殊属性 类2==&gt;新式类和旧式类，初步创建类和实例化 类3==&gt;类属性、创建实例、实例属性、self作用、类内外数据流转 类4==&gt;绑定方法和非绑定方法，类方法和静态方法 类5==&gt;继承，super，多重继承 多态和封装==&gt;多态，封装和私有化 定制类==&gt;类和类型，定制类 黑魔法==&gt;优化内存的__slots__，属性拦截 第伍章 错误和异常 错误和异常(1)==&gt;什么是错误和异常，常见异常类型，处理异常(try…except…)]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fsnippet%2F101.html</url>
    <content type="text"><![CDATA[python3基础语法python是一种解释型语言 Linux环境下编程打开终端输入python3即可进入python3 shell，要打开py文件直接在py文件所在位置终端输入python3 *.py，或输入绝对路径打开1234#!/usr/bin/env python3 # linux系统下必须，这是python3的环境变量#coding:utf-8 # 申明编码，非必须，便于阅读和维护a = 19 + 2 * 4 - 8 / 2 # 表达式print(a) # 函数 编译当运行.py文件的时候，Python会通过编译器，将它编译为.pyc文件。然后这个文件就在一个名为虚拟机的东西上运行，这个所谓的虚拟机是专门为Python设计的。有了虚拟机，使得Python可以跨平台 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。也可以为源码文件指定不同的编码： # -*- coding: cp-1252 -*- 标识符(给对象起名字) 一切皆可为对象 第一个字符必须是字母表中字母或下划线_。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 python保留字123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;] 注释 注释的作用便于读写和维护代码 单行注释用# # 程序运行时该注释不会显示 多行注释用三对引号 &quot;&quot;&quot; 多行注释 多行注释 &quot;&quot;&quot; 缩进与空格 python最具特色的就是使用缩进来表示代码块，不需要使用大括号{}。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数，为了统一规范一般用4个空格。 为了代码的整体美观、便于阅读和便于维护，用空格隔开不同的元素 代码换行 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\来实现多行语句，例如： 123total = item_one + \ item_two + \ item_three 在[] {}或()中的多行语句，不需要使用反斜杠\，例如： 12total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;, &apos;item_four&apos;, &apos;item_five&apos;] 一行显示多条语句,Python可以在同一行中使用多条语句，语句之间使用分号;分割: 1import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;) 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 在Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。对象有类型，变量无类型 数据类型Number（数字） int float boolTrue False，首字母必须大写 complex1+2jString可以索引和切片，不能被改变List有序，可以索引、切片、可变Tuple可以索引和切片，不能被改变Dictionary — {key:value}无序，元素是一对键值Set — {1,’a’}集合是一个无序不重复元素的序列。创建一个空集合必须用set()而不是{}，因为{}是用来创建一个空字典。| id()可以查看内存地址type()查看数据类型 变量在Python中，有这样一句话是非常重要的：对象有类型，变量无类型。Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。等号=用来给变量赋值。等号=运算符左边是一个变量名,等号=运算符右边是存储在变量中的值 Python3运算符 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 算术运算符a=10 b=4 运算符 描述 实例 结果 + 加 a+b 14 - 减 a-b 6 * 乘 a*b 40 / 除 a/b 2.5 % 取余 a%b 2 ** 幂 a**b 10000 // 取整除 a//b 2 凡是浮点型参与计算，结果都为浮点型 比较运算符a=10 b=4 运算符 描述 实例 结果 == 等于 a==b False != 不等于 a!=b True &gt; 大于 a&gt;b True &lt; 小于 a&lt;b False &gt;= 大于等于 a&gt;=b False &lt;= 小于等于 a&lt;=b False 赋值运算符 运算符 实例 描述 = c=a+b += c+=a c=c+a -= c-=a c=c-a *= c*=a c=c*a /= c/=a c=c/a %= c%=a c=c%a **= c**=a c=c**a //= c//=a c=c//a 位运算符 按位运算符是把数字看作二进制来进行计算的。 运算符 描述 &amp; 按位与运算符；参与运算符的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 按位或 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 ^ 按位异或运算符；当两队应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 按位或运算符|，md表格不能打出| 逻辑运算符and or not 成员运算符in not in 身份运算符is is not 运算符优先级 优先级 运算符 1 ** 2 ~ + - 3 * / % // 4 + - 5 &gt;&gt; &lt;&lt; 6 &amp; 7 ^ 按位或 8 &lt;= &lt;&gt; &gt;= 9 &lt;``&gt; == != 10 = %= /= //= -= += *= **= 11 is is not 12 in not in 13 not or and float精度问题&gt;&gt;&gt; 0.1 + 0.2 0.30000000000000004 &gt;&gt;&gt; 0.1 + 0.1 + 0.1 - 0.3 5.551115123125783e-17 原因在于十进制和二进制的转换上，电脑用的是二进制进行计算，上面的例子中，我们输入的是十进制，她就要把十进制的数转化为二进制，然后再计算。但是，在转化中，浮点数转化为二进制，就出问题了。 例如十进制的0.1，转化为二进制是：0.0001100110011001100110011001100110011001100110011… 也就是说，转化为二进制后，不会精确等于十进制的0.1。同时，计算机存储的位数是有限制的，所以，就出现上述现象了。这种问题不仅仅是Python中有，所有支持浮点数运算的编程语言都会遇到，它不是Python的bug。 使用numPy包和其它用于数学和统计学的包，可以解决上述问题 常用数学函数 函数 代码实例 返回值 描述 abs(x) abs(-1.2) 1.2 返回 x（数字）的绝对值，如果参数是一个复数，则返回它的大小 max(x) max(1,2) 2 返回给定参数的最大值，参数可以为序列 min(x) min(1,2) 1 返回给定参数的最小值，参数可以为序列 round(x[,n]) round(3.14,1) 3.1 返回浮点数x的四舍五入值,第二个参数规定保留的小数位数，不写则默认为0 math模块math是标准库之一，所以不用安装，可以直接使用。使用方法是： &gt;&gt;&gt; import math 函数 代码实例 返回值 描述 ceil(x) math.ceil(1.2) 2 返回一个大于或等于 x 的的最小整数 floor(x) math.floor(-1.2) -2 返回一个小于或等于 x 的的最小整数 exp(x) math.exp(math.pi) 23.140692632779267 返回x的指数,ex fabs(x) math.fabs(-1.2) 1.2 返回数字的绝对值,只对浮点型跟整型数值有效 sqrt(x) math.sqrt(100) 10 返回数字x的平方根 dir(module)：查看命令的属性和方法help()：查看帮助 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。1&gt;&gt;&gt; import random choice(seq)方法返回一个列表，元组或字符串的随机项 12random.choice(&apos;Runoob&apos;)---&gt;urandom.choice([1, 2, 3, 5, 9]))---&gt;3 randrange ([start,] stop [,step])方法返回指定递增基数集合中的一个随机数，基数缺省值为1。 start – 指定范围内的开始值，包含在范围内。 stop – 指定范围内的结束值，不包含在范围内。 step – 指定递增基数。1234# 从 1-100 中选取一个奇数random.randrange(1, 100, 2)---&gt;97# 从 0-99 选取一个随机数random.randrange(100)---&gt;42 random() 方法返回随机生成的一个实数，它在[0,1)范围内。 random.random()—&gt;0.09690599908884856 random.seed([x])改变随机数生成器的种子,此方法没有返回值。参数x 改变随机数生成器的种子seed。不必特别去设定seed，Python会选择seed。 random.shuffle(lst)方法将列表和元组的所有元素随机排序。 123list1 = [20, 16, 10, 5]random.shuffle(list1)list1 ---&gt;[20, 5, 16, 10] uniform(x, y)在[x,y]范围内,随机生成一个实数。 1random.uniform(5, 10)---&gt;7.054602800254241]]></content>
  </entry>
</search>
