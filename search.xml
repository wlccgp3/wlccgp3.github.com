<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[README.md]]></title>
    <url>%2F2018%2F01%2F11%2FREADME%2F</url>
    <content type="text"><![CDATA[网站插件扩展 hexo-deployer-git hexo-generator-searchdb disqus 配置文件问题主题配置可以放在source/_data/next.yml中，会覆盖掉主题内的配置站点配置不能写在source/_data/next.yml中，有的不能生效 gitment在github设置中Settings/Developer settings 创建一个新OAuth app注意：Homepage URL和Authorization callback URL就写github page里面显示的域名，如果绑定了域名，github page也会显示成绑定的域名]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2013%2F07%2F13%2Ftest%2F</url>
    <content type="text"><![CDATA[test123]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[htmls]]></title>
    <url>%2Fhtml%2Findex.html</url>
    <content type="text"><![CDATA[bokeh快速入门]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F107.html</url>
    <content type="text"><![CDATA[python数据存储原理变量 引用 对象1x = 1 内存中只创建了对象1，变量x只是贴在对象1的标签，=是赋值即引用在python中一切皆对象，里面又有不可变对象和可变对象 数字和字符串对象引用1234567&gt;&gt;&gt; a = 5 # 内存中创建了一个对象5&gt;&gt;&gt; b = 5&gt;&gt;&gt; b --&gt; 5&gt;&gt;&gt; id(a) --&gt; 139774080&gt;&gt;&gt; id(b) --&gt; 139774080 # 一个对象贴了两个标签&gt;&gt;&gt; b = 3 # 内存中新建了一个对象3&gt;&gt;&gt; id(b) --&gt; 10923616 # 对象引用换成了b 组合对象的引用(除了数字和字符串) 可以创建多个”一样”的对象,但是id不同1234567&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; id(x) --&gt; 140150136275912&gt;&gt;&gt; y = x[:]&gt;&gt;&gt; y --&gt; [1, 2, 3]&gt;&gt;&gt; id(y) --&gt; 140150136287496&gt;&gt;&gt; z = [1, 2, 3]&gt;&gt;&gt; id(z) --&gt; 140150136287944 解析:123456789&gt;&gt;&gt; x = &apos;a&apos;&gt;&gt;&gt; y = [&apos;a&apos;, 1, [&apos;a&apos;, 1]]&gt;&gt;&gt; id(x) --&gt; 140363897810368 # 对象&apos;a&apos;&gt;&gt;&gt; id(y) --&gt; 140363897692872 # 列表对象&gt;&gt;&gt; id(y[0]) --&gt; 140363897810368&gt;&gt;&gt; id(y[1]) --&gt; 10923552 # 列表的子对象数字1&gt;&gt;&gt; id(y[2]) --&gt; 140363897680840 # 列表子对象列表[&apos;a&apos;, 1]&gt;&gt;&gt; id(y[2][0]) --&gt; 140363897810368 # 三个 &apos;a&apos; id一样&gt;&gt;&gt; id(y[2][1]) --&gt; 10923552 # 两个 1 id一样 修改列表内容：123&gt;&gt;&gt; y.remove([&apos;a&apos;, 1])&gt;&gt;&gt; y --&gt; [&apos;a&apos;, 1]&gt;&gt;&gt; id(y) --&gt; 140363897692872 # 因为是修改原对象，所有id不变 可变对象的浅拷贝123456789&gt;&gt;&gt; x = &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125; # 最底层的对象只有1,2,3&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y --&gt; &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125;&gt;&gt;&gt; id(x) --&gt; 139791973166088&gt;&gt;&gt; id(y) --&gt; 139791973166024 # 父对象id显示不一样&gt;&gt;&gt; id(x[&apos;a&apos;]) --&gt; 10923552&gt;&gt;&gt; id(y[&apos;a&apos;]) --&gt; 10923552 # 子对象id一样&gt;&gt;&gt; id(x[&apos;b&apos;]) --&gt; 139791972639688&gt;&gt;&gt; id(y[&apos;b&apos;]) --&gt; 139791972639688 # 子对象id一样 从上面可以看出，浅复制只是创建一个新的父对象，子对象还是同一个对象 修改字典的列表1234567&gt;&gt;&gt; id(y[&apos;b&apos;][1]) --&gt; 10923584&gt;&gt;&gt; y[&apos;a&apos;] = 2 # 引用对象2&gt;&gt;&gt; id(y[&apos;a&apos;]) --&gt; 10923584&gt;&gt;&gt; y[&apos;b&apos;].remove(2)&gt;&gt;&gt; id(y[&apos;b&apos;]) --&gt; 139791972639688 # 列表子对象id没有改变&gt;&gt;&gt; y --&gt; &#123;&apos;b&apos;: [1, 3], &apos;a&apos;: 1&#125;&gt;&gt;&gt; x --&gt; &#123;&apos;b&apos;: [1, 3], &apos;a&apos;: 1&#125; 导入copy模块实现deep copy123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; x = &#123;&apos;a&apos;:1, &apos;b&apos;:[1, 2, 3]&#125;&gt;&gt;&gt; y = copy.copy(x) # 浅拷贝和前面一样&gt;&gt;&gt; z = copy.deepcopy(x) # 深拷贝&gt;&gt;&gt; id(x[&apos;b&apos;]) --&gt; 140541619106696&gt;&gt;&gt; id(z[&apos;b&apos;]) --&gt; 140541618998536 # 创建了两个列表对象&gt;&gt;&gt; z[&apos;b&apos;].remove(2)&gt;&gt;&gt; x --&gt; &#123;&apos;a&apos;: 1, &apos;b&apos;: [1, 2, 3]&#125;&gt;&gt;&gt; z --&gt; &#123;&apos;a&apos;: 1, &apos;b&apos;: [1, 3]&#125; deepcopy可以创建两个id不一样的可变对象，但不影响不可变对象 变量python引用变量的顺序： 当前作用域局部变量-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量global和nonlocal12345a = 1 # 全局变量，可省略global关键字def y(): a = a + 1 # 全局变量可以在函数内部使用，但不能修改y() # 报错 变量解析规则在python的作用域规则里面，创建变量一定会在当前作用域里创建一个变量，但是访问或者修改变量时会先在当前作用域查找变量，没有找到匹配变量的话会依次向上在闭合的作用域里面进行查看找 声明全局变量，如果在局部要对全局变量修改，需要在局部也要先声明该全局变量 在局部如果不声明全局变量，并且不修改全局变量。则可以正常使用全局变量 nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量 避免出错的办法，就是尽量不重复使用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F108.html</url>
    <content type="text"><![CDATA[列表相减解法一:用for循环123456789x = [1, 2, 3, 3, 2, 1]y = [1, 4]z = []for i in x: if i on in y: z.append(i)print(z) #--&gt; [2, 3, 3, 2] 解法二:用列表解析1234&gt;&gt;&gt; x = [1, 2, 3, 3, 2, 1]&gt;&gt;&gt; y = [1, 4]&gt;&gt;&gt; z = [i for i in x if i not in y]&gt;&gt;&gt; z #--&gt; [2, 3, 3, 2]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F121.html</url>
    <content type="text"><![CDATA[语句一般所有高级语言，都包含如下语句，Python也不例外： 循环语句:容许一些语句反复运行数次。循环可依据一个默认的数目来决定运行这些语句的次数；或反复运行它们，直至某些条件改变。 条件语句:容许仅当某些条件成立时才运行某个区块。否则，这个区块中的语句会略去，然后按区块后的语句继续运行。 无条件分支语句容许运行顺序转移到程序的其他部分之中。包括跳跃（在很多语言中称为Goto）、副程序和Procedure等。 循环、条件分支和无条件分支都是控制流程。 import导入模块12&gt;&gt;&gt; import math # 可读性强&gt;&gt;&gt; math.pow(3,2) --&gt; 9.0 导入模块中单个或多个方法1234&gt;&gt;&gt; from math import pow # 可读性差&gt;&gt;&gt; from math import e, pi&gt;&gt;&gt; pow(3,2) --&gt; 9.0&gt;&gt;&gt; pow(e,pi) --&gt; 23.140692632779263 导入模块中的函数并自定义名称12&gt;&gt;&gt; from math import pow as pingfang&gt;&gt;&gt; pingfang(3,2) --&gt; 9.0 导入模块中的所有方法12345&gt;&gt;&gt; from math import *&gt;&gt;&gt; pow(3,2)9.0&gt;&gt;&gt; sqrt(9)3.0 赋值语句 编程中的“=”和数学中的“=”是完全不同的。在编程语言中，“=”表示赋值过程。 多重赋值语句1234&gt;&gt;&gt; x, y, z = 1, &quot;python&quot;, [&quot;hello&quot;, &quot;world&quot;]&gt;&gt;&gt; x --&gt; 1&gt;&gt;&gt; y --&gt; &apos;python&apos;&gt;&gt;&gt; z --&gt; [&apos;hello&apos;, &apos;world&apos;] 变量值互换12345&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = 9&gt;&gt;&gt; a, b = b, a # 相当于标签互换&gt;&gt;&gt; a --&gt; 9&gt;&gt;&gt; b --&gt; 2 还有一种赋值方式，被称为“链式赋值”123&gt;&gt;&gt; m = n = &quot;python&quot;&gt;&gt;&gt; m --&gt; &quot;python&quot;&gt;&gt;&gt; n --&gt; &quot;python&quot;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F122.html</url>
    <content type="text"><![CDATA[if条件语句基本语法:12if bool(conj): # 如果if后面的条件满足，则执行后面的语句块 do something # 统一缩进4个空格 if … elif … else基本样式结构：123456789if 条件1: # 满足条件1则执行语句块1 语句块1elif 条件2: # 满足条件2则执行语句块2 语句块2elif 条件3： 语句块3...else: # 上面条件都都不满足才执行 语句块4 三元操作符12345&gt;&gt;&gt; x = -1&gt;&gt;&gt; y = 1 if x &gt; 0 else 2&gt;&gt;&gt; y --&gt; 2&gt;&gt;&gt; x = 2&gt;&gt;&gt; y --&gt; 1]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F123.html</url>
    <content type="text"><![CDATA[for循环其基本结构是：12for 循环规则： # 冒号:结束 操作语句 # 缩进四个空格 字符串for循环：123456789&gt;&gt;&gt; hello = &quot;world&quot;&gt;&gt;&gt; for i in hello: # 冒号:结束... print(i) # print自带end=&apos;\n&apos;... world 循环的对象必须是可迭代的对象，判断是否存在:12&gt;&gt;&gt; &apos;__iter__&apos; in dir(1) --&gt; False&gt;&gt;&gt; &apos;__iter__&apos; in dir(list) --&gt; True range(start,stop[, step]) –&gt; range object start：开始数值，缺省则为0 stop：结束的数值，必须要写，取值为stop-1 step：变化的步长，缺省则为1 stop&gt;start : step&gt;0(非必须) stop&lt;start : step&lt;0(非必须) while循环12while 判断条件: # 冒号:结束 语句 # 缩进4个空格 break语句跳出 for 和 while 的循环体 continue语句跳过当前循环块中的剩余语句，然后继续进行下一轮循环 pass语句空语句，是为了保持程序结构的完整性，pass不做任何事情，一般用做占位语句]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F124.html</url>
    <content type="text"><![CDATA[并行迭代迭代两个以上的集合 zip(iter1 [,iter2 […]]) –&gt; zip object问题:多个矩阵元素互换12345678&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = [4, 5, 6]&gt;&gt;&gt; z = [7, 8, 9]&gt;&gt;&gt; xyz = list(zip(x, y, z))&gt;&gt;&gt; xyz #--&gt; [(1, 4, 7), (2, 5, 8), (3, 6, 9)]&gt;&gt;&gt; zyx = list(zip(*xyz)) # 参数加*解压&gt;&gt;&gt; zyx #--&gt; [(1, 2, 3), (4, 5, 6), (7, 8, 9)] 问题：有两个列表，分别是：a = [1, 2, 3, 4, 5], b = [9, 8, 7, 6, 5]，要计算这两个列表中对应元素的和。方法一:1234567&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; b = [9, 8, 7, 6, 5]&gt;&gt;&gt; c = []&gt;&gt;&gt; for i in range(len(a)):... c.append(a[i]+b[i])... &gt;&gt;&gt; c #--&gt; [10, 10, 10, 10, 10] 方法二:12345&gt;&gt;&gt; d = []&gt;&gt;&gt; for x,y in zip(a,b):... d.append(x+y)... &gt;&gt;&gt; d #--&gt; [10, 10, 10, 10, 10] 用列表解析:1234&gt;&gt;&gt; x = [a[i]+b[i] for i in range(len(a))]&gt;&gt;&gt; x #--&gt; [10, 10, 10, 10, 10]&gt;&gt;&gt; y = [x+y for x,y in zip(a,b)]&gt;&gt;&gt; y #--&gt; [10, 10, 10, 10, 10] 问题:字典键值互换用for循环:123456&gt;&gt;&gt; d = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;&gt;&gt;&gt; m = &#123;&#125;&gt;&gt;&gt; for k, v in d.items():... m[v] = k # 以v为key,以k为values添加键值对...&gt;&gt;&gt; m #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125; 因为字典有items方法,而zip只能获得key:12&gt;&gt;&gt; x = dict(zip(d.values(),d.keys()))&gt;&gt;&gt; x #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125; 用dict解析:12&gt;&gt;&gt; y = &#123;v:k for k, v in d.items()&#125;&gt;&gt;&gt; y #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F126.html</url>
    <content type="text"><![CDATA[文件打开文件1open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opene r=None) 模式 描述 r 以读方式打开文件，可读取文件信息,默认模式 w 以写方式打开文件，可向文件写入信息。如文件存在，则清空该文件，再写入新内容 x 以写模式新建一个文件 a 以追加模式打开文件（文件指针自动移到文件末尾），如果文件不存在则创建 + 配合其他模式r,w,a等,以读和写模式 b 二进制模式 12&gt;&gt;&gt; f = open(&quot;130.txt&quot;) # 在当前文件夹打开已存在的文件&gt;&gt;&gt; dir(f) 在对文件进行写入操作之后，一定要牢记一个事情：file.close() with…as…用with语句不用关闭文件123&gt;&gt;&gt; with open(&quot;130.txt&quot;,&quot;a&quot;) as f:... f.write(&quot;\nThis is about &apos;with...as...&apos;&quot;)... 常用文件方法f.read([size])如果指定了参数size，就按照该指定长度从文件中读取内容，否则，就读取全文直到EOF f.readline([size]) 如果指定了参数size,则读取指定长度的内容,直到行尾才会读取下一行 如果不指定参数,则一行一行读取 f.readlines([hint]) 返回该文件中包含的所有行。 如果设置可选参数hint, 则读取指定长度的字节, 并且将这些字节按行分割 EOF(End-of-file) f.write(string)将 string 写入到文件中, 然后返回写入的字符数 f.tell()返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数 f.seek(offset[, whence])这个函数的功能就是让指针移动。whence的值： 默认值是0，表示从文件开头开始计算指针偏移的量（简称偏移量）。此时offset必须是大于等于0的整数。 是1时，表示从当前位置开始计算偏移量。offset如果是负数，表示从当前位置向前移动，整数表示向后移动。 是2时，表示相对文件末尾移动。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F128.html</url>
    <content type="text"><![CDATA[在使用Python的过程中，很容易混淆如下几个关联的概念： 容器(container) 可迭代对象(Iterable) 迭代器(Iterator) 生成器(generator) list, set, dict解析式 生成器表达式 容器（container)容器是用来储存元素的一种数据结构，它支持隶属测试，容器将所有数据保存在内存中，在Python中典型的容器有： list， deque, … set，frozesets，… dict, defaultdict, OrderedDict, Counter, … tuple, namedtuple, … str 用in,not in判断是否存在,字典容器通过检查是否包含键来进行判断,字符串通过检查是否包含某个子串来判断123&gt;&gt;&gt; 1 in [1,2,3] #--&gt; True&gt;&gt;&gt; 4 in [1,2,3] #--&gt; False&gt;&gt;&gt; 4 not in [1,2,3] #--&gt; True 注意：并非所有的容器都是可迭代对象。 可迭代对象正如前面所提到的，大部分容器都是可迭代的，但是还有其他一些对象也可以迭代，例如，文件对象以及管道对象等等123456&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; y = iter(x）&gt;&gt;&gt; next(y) #--&gt; 1&gt;&gt;&gt; next(y) #--&gt; 2&gt;&gt;&gt; type(x) #--&gt; &lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(y) #--&gt; &lt;class &apos;list_iterator&apos;&gt; 在这里，x是可迭代对象。而y是迭代器，可以从可迭代对象x中获取值。 注意：可迭代的类中，一般实现以下两个方法，__iter__()以及__next()__方法，__iter__()方法返回self。 实际调用过程如下： 迭代器(Iterators) 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从第一个元素开始访问，直到所有的元素被访问完结束。 迭代器只能往前不会后退。 迭代器有两个基本的方法：__iter__() 和 __next__() itertools模块1234&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start=13)&gt;&gt;&gt; next(counter) --&gt; 13&gt;&gt;&gt; next（counter) --&gt; 14 无限序列：123456&gt;&gt;&gt; from itertools import cycle&gt;&gt;&gt; colors = cycle([&quot;red&quot;,&quot;white&quot;,&quot;blue&quot;])&gt;&gt;&gt; next(colors) --&gt; &quot;red&quot;&gt;&gt;&gt; next(colors） --&gt; &quot;white&quot;&gt;&gt;&gt; next(colors) --&gt; &quot;blue&quot;&gt;&gt;&gt; next(colors) --&gt; &quot;red&quot; 无限序列生成有限序列：123456789&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; colors = cycle([&apos;red&apos;, &apos;white&apos;, &apos;blue&apos;]) # infinite&gt;&gt;&gt; limited = islice(colors, 0, 4) # finite&gt;&gt;&gt; for x in limited: # so safe to use for-loop on... print(x)redwhitebluered 生成器(generator)带有yield关键字的的函数在Python中被称之为 generator(生成器)。一个函数或者子程序都只能return一次，但是一个生成器能暂停执行并返回一个中间的结果。 生成器其实就是一种特殊的迭代器 生成器的另一个优点就是无须将对象的所有元素都存入内存之后，才开始进行操作。生成器仅在迭代至某个元素时才会将该元素放入内存，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的类序列对象，EG. 大文件/大集合/大字典/斐波那契数列等。这个特点被称为 延迟计算 或 惰性求值(Lazy evaluation)，可以有效的节省内存。 list解析式12[expr for iter_var in iterable] # 最终生成一个列表[expr][expr for iter_var in iterable if cond_expr] 代码实例：12345&gt;&gt;&gt; x = [(x+1,y+1) for x in range(2) for y in range(3)] &gt;&gt;&gt; x #--&gt; [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)]&gt;&gt;&gt; y = [x+10 for x in range(10) if x&gt;5]&gt;&gt;&gt; y #--&gt; [16, 17, 18, 19] 还有集合解析，类似列表解析，区别在于结果满足集合的特性 dict解析式123&gt;&gt;&gt; x = &#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3, &quot;d&quot;:4&#125;&gt;&gt;&gt; y = &#123;v:k for k,v in x.items()&#125;&gt;&gt;&gt; y #--&gt; &#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125; 生成器表达式12(expr for iter_var in iterable)(expr for iter_var in iterable if cond_expr) 当序列过长，而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被()括起来的，而不是[]1234567891011&gt;&gt;&gt; y = (x+10 for x in range(10) if x&gt;5)&gt;&gt;&gt; y&lt;generator object &lt;genexpr&gt; at 0x7faeee369d58&gt;&gt;&gt;&gt; y.__next__() #--&gt; 16&gt;&gt;&gt; y.__next__() #--&gt; 17&gt;&gt;&gt; y.__next__() #--&gt; 18&gt;&gt;&gt; y.__next__() #--&gt; 19&gt;&gt;&gt; y.__next__()StopIteration Traceback (most recent call last)&lt;ipython-input-18-989149fd7263&gt; in &lt;module&gt;()----&gt; 1 y.__next__() 生成器表达式并不真正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”(yield)出来。 生成器表达式使用了“惰性计算”(lazy evaluation)，只有在检索时才被赋值 (evaluated)，所以在列表比较长的情况下使用内存上更有效。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F130.html</url>
    <content type="text"><![CDATA[自省 来源《Python自省指南》 联机帮助在交互模式下，用help向python请求帮助。1234567891011121314151617&gt;&gt;&gt; help()Welcome to Python 3.5&apos;s help utility!If this is your first time using Python, you should definitely check outthe tutorial on the Internet at http://docs.python.org/3.5/tutorial/.Enter the name of any module, keyword, or topic to get help on writingPython programs and using Python modules. To quit this help utility andreturn to the interpreter, just type &quot;quit&quot;.To get a list of available modules, keywords, symbols, or topics, type&quot;modules&quot;, &quot;keywords&quot;, &quot;symbols&quot;, or &quot;topics&quot;. Each module also comeswith a one-line summary of what it does; to list the modules whose nameor summary contain a given string such as &quot;spam&quot;, type &quot;modules spam&quot;.help&gt; 这时候就进入了联机帮助状态，根据提示输入keywords12345678910111213help&gt; keywordsHere is a list of the Python keywords. Enter any keyword to get more help.False def if raiseNone del import returnTrue elif in tryand else is whileas except lambda withassert finally nonlocal yieldbreak for notclass from orcontinue global pass 如果从文档说明界面返回到帮助界面，需要按q键。从联机帮助状态退回到python的交互模式，使用quit命令。 dir()dir() 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则 dir() 返回当前作用域中的名称。让我们将 dir() 函数应用于 keyword 模块，并观察它揭示了什么：123456&gt;&gt;&gt; import keyword&gt;&gt;&gt; dir(keyword)[&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;iskeyword&apos;, &apos;kwlist&apos;, &apos;main&apos;]&gt;&gt;&gt; __builtins__&lt;module &apos;__builtin__&apos; (built-in)&gt; 注：如果您在磁盘上寻找 __builtin__.py 文件，将空手而归。这个特殊的模块对象是 Python 解释器凭空创建的，因为它包含着解释器始终可用的项。尽管看不到物理文件，但我们仍可以将 dir() 函数应用于这个对象，以观察所有内置函数、错误对象以及它所包含的几个杂项属性。12&gt;&gt;&gt; dir(__builtins__)[省略...... &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;ascii&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;ngettext&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] dir() 函数适用于所有对象类型，包括字符串、整数、列表、元组、字典、函数、定制类、类实例和类方法 dir(42),dir([]),dir(()),dir({}),dir(dir) 检查python对象在计算机术语中，对象是拥有标识和值的事物，属于特定类型、具有特定特征和以特定方式执行操作。并且，对象从一个或多个父类继承了它们的许多属性。除了关键字和特殊符号（像运算符，如 + 、 - 、 、 * 、 / 、 % 、 &lt; 、 &gt; 等）外，Python 中的所有东西都是对象。Python具有一组丰富的对象类型：字符串、整数、浮点、列表、元组、字典、函数、类、类实例、模块、文件等。 当您有一个任意的对象（也许是一个作为参数传递给函数的对象）时，可能希望知道一些关于该对象的情况。如希望python告诉我们： 对象的名称是什么？ 这是哪种类型的对象？ 对象知道些什么？ 对象能做些什么？ 对象的父对象是谁？ 文档字符串__doc__属性__doc__ 这个属性是一个字符串，它包含了描述对象的注释。Python 称之为文档字符串或docstring如果模块、类、方法或函数定义的第一条语句是字符串，那么该字符串会作为对象的 __doc__ 属性与该对象关联起来。例如，看一下str类型对象的文档字符串。 名称__name__属性 如果模块是被导入，__name__的值为模块名字 如果是被直接执行，__name__的值为__main__ 此处所说的模块可以简单理解为一个.py文件 并非所有对象都有名称，但那些有名称的对象都将名称存储在其 __name__ 属性中。注：名称是从对象而不是引用该对象的变量中派生的。 12345678if __name__ == &apos;__main__&apos;: # Do something appropriate here, like calling a # main() function defined elsewhere in this module. main()else: # Do nothing. This module has been imported by another # module that wants to make use of the functions, # classes and other useful bits it has defined. 类型type()1234&gt;&gt;&gt; type(42) #--&gt; &lt;type &apos;int&apos;&gt;&gt;&gt;&gt; type([]) #--&gt; &lt;type &apos;list&apos;&gt;&gt;&gt;&gt; type(&#123;&#125;) #--&gt; &lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; type(dir) #--&gt; &lt;type &apos;builtin_function_or_method&apos;&gt; 标识id()检测是否存在属性in/not in可调用callable() callable()方法用来检测对象是否可被调用，可被调用指的是对象能否使用()括号的方法调用。 可调用对象，在实际调用也可能调用失败；但是不可调用对象，调用肯定不成功。 类对象都是可被调用对象，类的实例对象是否可调用对象，取决于类是否定义了call方法。 实例在 type() 函数提供对象的类型时，还可以使用 isinstance() 函数测试对象，以确定它是否是某个特定类型或定制类的实例： 子类关于类的问题，有一个“继承”概念，有继承就有父子问题，这是在现实生活中很正常的，在编程语言中也是如此。虽然这是后面要说的，但是，为了本讲内容的完整，也姑且把这个内容放在这里。读者可以不看，留着以后看也行。我更建议还是阅读一下，有个印象。 在类这一级别，可以根据一个类来定义另一个类，同样地，这个新类会按照层次化的方式继承属性。Python 甚至支持多重继承，多重继承意味着可以用多个父类来定义一个类，这个新类继承了多个父类。 issubclass() 函数使我们可以查看一个类是不是继承了另一个类： python文档1.文档是一种对软件系统的书面描述；2.文档应当精确地描述软件系统；3.软件文档是软件工程师之间用作沟通交流的一种方式；4.文档的类型有很多种，包括软件需求文档，设计文档，测试文档，用户手册等；5.文档的呈现方式有很多种，可以是传统的书面文字形式或图表形式，也可是动态的网页形式 python文档的网址：https://docs.python.org/2/，这是python2.x，从这里也可以找到python3.x的文档。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F204.html</url>
    <content type="text"><![CDATA[递归 递归（recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。 根据斐波那契数列的定义，可以直接写成这样的斐波那契数列递归函数。12345678910111213141516#!/usr/bin/env python3# coding=utf-8def fib(n): &quot;&quot;&quot; This is Fibonacci by Recursion. &quot;&quot;&quot; if n==0: return 0 elif n==1: return 1 else: return fib(n-1) + fib(n-2)n = int(input(&apos;输入正整数:&apos;))print(fib(n)) 解析当n = 4时：12345fib(4) = fib(3) + fib(2) ↓ ↓ fib(2) + fib(1) fib(1) + fib(0) ↓ fib(1) + fib(0) 相当于fib(4) = 3fib(1) + 2fib(0) -&gt; 3 上面的代码每次递回下一级函数，都要判断一次判断一次if和elif 相当于 优化代码123456789101112#!/usr/bin/env python# coding=utf-8d = &#123;0:0, 1:1&#125; def fib(n): if not n in d: d[n] = fib(n-1) + fib(n-2) return d[n]n = int(input(&apos;输入正整数:&apos;))print(d(n)) 用递归函数要小心，因为很容易陷入死循环]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F202.html</url>
    <content type="text"><![CDATA[built-in function&gt;&gt;&gt; dir(__builtins__) [...省略... &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;ascii&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;exec&apos;, &apos;exit&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;vars&apos;, &apos;zip&apos;] 常用内建函数[&apos;dir&apos;, &apos;format&apos;, &apos;help&apos;, &apos;id&apos;, &apos;input&apos;, &apos;open&apos;, &apos;print&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;type&apos;, &apos;input&apos;, &apos;zip&apos;] 数学相关[&apos;abs&apos;, &apos;len&apos;, &apos;max&apos;, &apos;min&apos;, &apos;pow&apos;, &apos;round&apos;, &apos;reversed&apos;, &apos;sorted&apos;, &apos;sum&apos;, &apos;divmod&apos;] 数据类型[&apos;bool&apos;, &apos;complex&apos;, &apos;dict&apos;, &apos;list&apos;, &apos;str&apos;, &apos;int&apos;, &apos;float&apos;, &apos;tuple&apos;, &apos;set&apos;, &apos;iter&apos;] 函数式编程[&apos;filter&apos;, &apos;map&apos;] 0-255与相应ascii码转换[&apos;chr&apos;, &apos;ord&apos;] 进制转换[&apos;bin&apos;, &apos;hex&apos;, &apos;oct&apos;] 类相关[&apos;callable&apos;, &apos;classmethod&apos;, &apos;delattr&apos;, &apos;getattr&apos;, &apos;hasattr&apos;, &apos;issubclass&apos;, &apos;isinstance&apos;, &apos;setattr&apos;, &apos;staticmethod&apos;, &apos;super&apos;] 变量相关[&apos;globals&apos;, &apos;locals&apos;, &apos;vars&apos;] 内建函数简介 abs() 获取绝对值 all() 接受一个迭代器，如果迭代器的所有元素都为真，那么返回True，否则返回False any() 接受一个迭代器，如果迭代器里有一个元素为真，那么返回True,否则返回False ascii() 调用对象的repr()方法，获得该方法的返回值. bin() 将十进制数分别转换为2进制 oct() 将十进制数分别转换为8进制 hex() 将十进制数分别转换为16进制。 bool() 测试一个对象是True还是False. bytes() 将一个字符串转换成字节类型 str() 将字符类型/数值类型等转换为字符串类型 challable() 判断对象是否可以被调用，能被调用的对象就是一个callables对象，比如函数和带有call()的实例 char()，13. ord() 查看十进制数对应的ASCII字符/查看某个ASCII对应的十进制数 classmethod() 用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法 complie() 将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译 complex() delattr() 删除对象的属性 dict() 创建数据字典 dir() 不带参数时返回当前范围内的变量，方法和定义的类型列表，带参数时返回参数的属性，方法列表 divmod() 分别取商和余数 enumerate() 返回一个可以枚举的对象，该对象的next()方法将返回一个元组 eval() 将字符串str当成有效的表达式来求值并返回计算结果 exec() 执行字符串或complie方法编译过的字符串，没有返回值 filter() 过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据 float() 讲一个字符串或整数转换为浮点数 format() 格式化输出字符串 frozenset() 创建一个不可修改的集合 getattr() 获取对象的属性 globals() 返回一个描述当前全局变量的字典 hasattr() 判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object，name)）是否抛出异常来实现的。 hash() 哈希值 help() 返回对象的帮助文档 id() 返回对象的内存地址 input() 获取用户输入内容 int() 将一个字符串或数值转换为一个普通整数 isinstance() 检查对象是否是类的对象，返回True或False issubclass() 检查一个类是否是另一个类的子类。返回True或False iter() 返回一个iterator对象 len() 返回对象长度 list() 列表构造函数 locals() 打印当前可用的局部变量的字典 map(function, iterable,…) 对于参数iterable中的每个元素都应用fuction函数，并将结果作为列表返回。 max() 返回给定元素里最大值 min() 返回给定元素里最小值 next() 返回一个可迭代数据结构（如列表）中的下一项 object() 获取一个新的，无特性(geatureless)对象。Object是所有类的基类。它提供的方法将在所有的类型实例中共享。 open() 打开文件 pow() 幂函数 property() range() 根据需要生成一个指定范围的数字，可以提供你需要的控制来迭代指定的次数 repr() 将任意值转换为字符串，供计时器读取的形式 reversed() 反转，逆序对象 round() 四舍五入 set() 集合构造函数 setattr() 与getattr()相对应 slice() 切片功能 sorted() 排序 staticmethod() str() 字符串构造函数 sum() 求和 super() 调用父类的方法 tuple() 元组构造函数 type() 显示对象所属的类型 vars() 返回 __dict__ 属性, 比如模块, 类, 实例, 或者其他 带有 __dict__ 属性的 object zip() 将对象逐一配对]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F237.html</url>
    <content type="text"><![CDATA[Python是支持多种范型的语言，可以进行所谓函数式编程，其突出体现在有这么几个函数：filter、map、reduce、lambda、yield。 匿名函数lambda 在lambda后面直接跟变量 变量后面是冒号 冒号后面是表达式，表达式计算结果就是本函数的返回值 123lambda x: x * x #--&gt; def func(x): return(x*x)lambda x: x%2lambda x, y: (x, y) #--&gt; def f(x, y): return (x, y) map(function, iterable[,iterable2])原理是: iterable的数量必须和function的参数一致 按顺序一一对应从可迭代对象传入参数3.函数返回的值是一个以list的形式的map对象 1234567&gt;&gt;&gt; lst1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; lst2 = [6, 7, 8, 9, 0]&gt;&gt;&gt; lst3 = [7, 8, 9, 2, 1]&gt;&gt;&gt; x = map(lambda x,y,z: x+y+z, lst1, lst2, lst3) #--&gt; &lt;map object at 0x7f2a502419e8&gt;&gt;&gt;&gt; list(x) #--&gt; [14, 17, 20, 15, 6]&gt;&gt;&gt; y = [x+y+z for x, y, z in zip(lst1, lst2, lst3)]&gt;&gt;&gt; y #--&gt; [14, 17, 20, 15, 6] reduce12&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x,y: x*y,[1, 2, 3, 4, 5]) #--&gt; 120 filter1234&gt;&gt;&gt; numbers = range(-2,3)&gt;&gt;&gt; numbers #--&gt; [-2, -1, 0, 1, 2]&gt;&gt;&gt; filter(lambda x: x&gt;0, numbers) #--&gt; [1, 2]&gt;&gt;&gt; [x for x in numbers if x&gt;0] #--&gt; [1, 2]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F401.html</url>
    <content type="text"><![CDATA[构造和初始化new(cls, […) new 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法。 new 方法相当不常用,但是它有自己的特性，特别是当继承一个不可变的类型比如一个tuple或者string。 init(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。 调用 x = SomeClass(10, ‘foo’)，那么 init 将会得到两个参数10和foo。 del(self) 如果 new 和 init 是对象的构造器的话，那么 del 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.del() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 del 能够被执行，所以 del can’t serve as a replacement for good coding practices ()~~ 特殊属性调用机制 类属性调用原理目的 所编写代码 Python 实际调用类构造器x = MyClass() –&gt; x.new()类析构器del x –&gt; x.del()只定义特定集合的某些属性x.slots()自定义散列值hash(x) x.hash()获取某个属性的值x.color type(x).dict[‘color’].get(x, type(x))设置某个属性的值x.color = ‘PapayaWhip’ type(x).dict[‘color’].set(x, ‘PapayaWhip’)删除某个属性del x.color type(x).dict[‘color’].del(x)控制某个对象是否是该对象的实例your class isinstance(x, MyClass) MyClass.instancecheck(x)控制某个类是否是该类的子类issubclass(C, MyClass) MyClass.subclasscheck(C)控制某个类是否是该抽象基类的子类issubclass(C, MyABC) MyABC.subclasshook(C) __getattr__() 和 __getattribute__()文件中的__main__.py 和 __init__.pypython3 xxx.py python3 -m xxx.py 这是两种加载py文件的方式: 叫做直接运行 相当于import,叫做当做模块来启动，前提是已加入sys.path python 将一个文件夹作为 package 对待，那么这个文件夹中必须包含一个名为 init.py 的文件，即使它是空的如果你需要 python 讲一个文件夹作为 package 执行，那么这个文件夹中必须包含一个名为 main.py 的文件，当执行 python3 -m hhlb 或者python3 hhlb 的时候，这个文件中的代码都会被执行。 在 hhlb/init.py 中写入如下内容：123print(&apos;__init__&apos;)print(&apos;__init__.__name__&apos;, __name__)print(&apos;__init__.__package__&apos;, __package__) 在 hhlb/main.py 中写入如下内容：123print(&apos;__main__&apos;)print(&apos;__main__.__name__&apos;, __name__)print(&apos;__main__.__package__&apos;, __package__) 执行 python3 hhlb ：1234-&gt; % python3 hhlb__main____main__.__name__ __main____main__.__package__ 这说明，将 hhlb 当作文件夹执行的时候，对于 main.py 来说，变量package 是一个空字符串。而 init.py 不会被执行。 执行 python3 -m hhlb ：1234567-&gt; % python3 -m hhlb__init____init__.__name__ hhlb__init__.__package__ hhlb__main____main__.__name__ __main____main__.__package__ hhlb 当作为模块执行的时候，python 会先执行 init.py ，然后执行main.py 。而且，前者和后者对于 name 变量的理解是不同的。 alll对于from ModuleName import * 这种形式，要特别注意重名现象。 Python中，对于一个模块，具有一个名为 all的属性，该属性的值就是被from ModuleName import *这样的语句绑定的属性列表；否则，这种类型的from语句将绑定模块中除了以下划线开始的属性（私有属性）外的所有属性。这样的话，对于同一个名空间里 面出现重名现象的概率就加大了，为了减少这种情况的发生，都会在模块开始处定义all属性的内容，写出可以被这种from类型导入的属性下面的是os.py里面的一段代码：all = [“altsep”, “curdir”, “pardir”, “sep”, “pathsep”, “linesep”,”defpath”, “name”, “path”, “devnull”] 其他globals:global namespace in which this function was definedfile:filename (missing for built-in modules) 内建特殊属性用dir(__builtins__)查看内建特殊属性，特殊属性都是以双下划线开头和结尾1&apos;__build_class__&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos; inspect模块type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.12import inspectdir(inspet) inspect.getmembers()12345Help on function getmembers in module inspect:getmembers(object, predicate=None) Return all members of an object as (name, value) pairs sorted by name. Optionally, only return members that satisfy a given predicate.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fpython3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Findex.html</url>
    <content type="text"><![CDATA[Python3学习笔记 Python3学习笔记 第壹章 基本数据类型 python3基本语法 字符串 列表 元组 字典 集合 数据存储原理 实战 第贰章 语句和文件 语句 ==&gt; import, 赋值语句、增量赋值 条件语句 ==&gt; if…elif…else语句，三元操作 循环语句 ==&gt; for、while循环，break、continue语句，range() 迭代 ==&gt; 可迭代对象、迭代器、生成器、列表解析 并行迭代 ==&gt; for循环 vs zip() 文件 ==&gt; 文件打开，读取，写入，常用方法 自省 ==&gt; help()，dir()，文档字符串，检查对象，文档 第叁章 函数 函数==&gt;定义函数方法，调用函数方法，参数 内建函数 递归==&gt;递归、传递函数、嵌套函数 闭包、装饰器 函数5==&gt;filter、map、reduce、lambda 命名空间==&gt;全局变量和局部变量，作用域，命名空间 第肆章 类 特殊属性==&gt;内建和特殊属性 类2==&gt;新式类和旧式类，初步创建类和实例化 类3==&gt;类属性、创建实例、实例属性、self作用、类内外数据流转 类4==&gt;绑定方法和非绑定方法，类方法和静态方法 类5==&gt;继承，super，多重继承 多态和封装==&gt;多态，封装和私有化 定制类==&gt;类和类型，定制类 黑魔法==&gt;优化内存的__slots__，属性拦截 第伍章 错误和异常 错误和异常(1)==&gt;什么是错误和异常，常见异常类型，处理异常(try…except…)]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
